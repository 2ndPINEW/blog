{
  "title": "1日1TypeChallenges",
  "description": "1日1TypeChallengesして、型の理解を深めます",
  "icon": "/assets/Typescript_logo_2020.png",
  "date": "2023/01/18",
  "tags": ["TypeChallenges", "TypeScript"]
}
---metadata

## Pick
`T`から`K`のプロパティを抽出する型です

### 使い方例
```typescript
interface A {
  a: string
  b: number
}

type t0 = Pick<A, 'a'>
// { a: string }
```

### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsELQQAoEsDGBrS8491gRgJ4QCCAdgC4AWA9mcQGICuEAFAAICGlAZkwJQQAxIFwlQFi+wpmWR1h+JsgA2FOMjJgsQrREBXMYHlVDVEAivoH8GQD3xJwHYMgaPVAZwyAfhkBjDIGKGQFcMLgAYoMAHgAqADQQANIAfB6ASQyA-vKAFK6A2gyAWgyAgAwefh6A0gyAkQwewR6WgOsMgLcMgIsMLhGAvUaAX4qAmgyA0QzWEYD52oCjEYDqDIB+DNWAQAyGEIDR8oASDIAODIBY-70eExQAzlhqFACmAE48nKjzEH40ACY0EADeWFAUyBSK8wBcEFMUi2oA5ocQW-NTqLcADsd0l9e3ZA9QKCoGgAW3eZwWW0u+BoNDO3CwAF9ehRCO91psdohFvMAG7IeYAdwgAF4IABZQjedD+bY0IIAcmOp3mDIgAB8IAzgWCIfMtgzQr1gWRrhAKHTLpiaNi8QTiWSDoDAcyzpcGQBheFkCCLWEghkBR5A0Hg+aQy4rRRTeZGqDIqATDy9UIQADiJwAEkx8IBzBkAXR6AWKi6iMqBQKO8pudgMBpqgqAA6ABWUwTNEWd2A0GASc4YBAwA0oAgAH0y+WK+WIIBlBmrgGsGQDNDPZAJMMEUAGFGAU0VS5WeyWIAWNHMlis1qR9lhOD8bvcCJcyEwQfglmBkWBUejxQAGUlINA0kiMziCjTr9YUACMO-Q80INB4pBPaPWlOp-gg8wAHgsyFsphAaPgSbzKgFBBME75fvMP5-tet73n4rqKlgADaiAQGoIQALpSqhmErkWIDdr2FYQI4gCdDIAEwyAI0M9hkURxFlv2hbIGC6YUOKT77BAACiACOTCcIoQTcR+6IgRAiIQDweogly7CnnA8aCWc-wvMATDHNaDKPhuqCcDaf5kshWAiWJFA+HxAmKBZonAZC55BC+e60jsjKqqyoSeXaPG2SBFn8YJNlmfyABMjlUs50puScZxspy3KmnyAqeaE3kxhA8lTHAn5mdlix6osWBOb4UVcu5cVcjyZqQhVDJqLignIMlRp4WAQ7LKsGJ0uORwxRcVzTv8WDPK8HxfGQU5-ACEBVUl0Kwtq+FtZQw6dT5wVbJeSrin1k0zqu7Ujuspl2aFPU7Sye1DSavLmvy81wvMCKrsWDEkYAhNaWGRjiAMMM+T0QxTFgKAWCuoAx5GACreESAI6KgCQ5iGYYRlGMZxomKZphmWbANwUyEksOZ5lA4NQ4A0ZG1KG4aRtGsavGjqbppm2ZTHCGkyKKoMQIAugyWIAa3KWIATVGADIZFNI9TqPJvTmO5vmhZAA)

```typescript
type MyPick<T extends object, K extends keyof T> = {
  [P in K]: T[P]
}
```
`<T extends object, K extends keyof T>`で、引数Tがオブジェクト、引数KがTのプロパティ名をユニオン型で持つ必要がある物として定義します。

`[P in K]: T[P]`の部分が、Kを反復処理して、Pにそれぞれのプロパティ名が入るので、`T[P]`でプロパティの元の型を取り出します

#### [keyof](https://typescriptbook.jp/reference/type-reuse/keyof-type-operator)
オブジェクト型からプロパティ名を型として返す型演算子。
プロパティ名が2つ以上ある場合は全てのプロパティ名がユニオン型で返る。

```typescript
interface A {
  a: string
  b: number
}

type t1 = keyof A
// 'a' | 'b'
```

#### [extends(型引数の制約)](https://typescriptbook.jp/reference/generics/type-parameter-constraint)
型引数にextendsキーワードを用いることで、ジェネリクスの型Tを特定の型に限定することができる

以下の例では、`T`が`HTMLElement`であることが保証される
```typescript
function changeBackgroundColor<T extends HTMLElement>(element: T) {
  element.style.backgroundColor = "red";
  return element;
}
```

#### [Mapped Types](https://typescriptbook.jp/reference/type-reuse/mapped-types)
`in`がユニオンで与えられた値をforみたいに反復処理するイメージ

```typescript
type SystemSupportLanguage = "en" | "fr";
type Butterfly = {
  [key in SystemSupportLanguage]: string;
};
// { en: string, fr: string }
```

## Readonly
`T`の全てのプロパティを読み取り専用にする型です

### 使い方例
```typescript
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBDsELQQEoFMCGATA9gOwDYE9J44TSiAjfCAQWwBcALHKgMQFcIAKAAVXoDM2ASggBiQLhKgLF8x5NgEtcdOHOxiATmix4qozOQBWyAMZKA1snwBnMEVF2IgK5jA8qo2ogEV9A-gyAe+I+A7BkDR6oBnDIA-DIBjDIDFDIBXDBEABigYOAQAPAAqAHwxgEkMgP7ygBSugNoMgFoMgIAMMSkxEL6AmgyAngyAZgy+gOsMgLcMgIsMEZmAtVEegGvKgFEMgEA6uYDWDFWA0Qz+mYD52oCjEYDqDIB+DFWAQAyzgKoMgDEMgPoM-k1tEYD2DICxioBOSn2Ayvp1gOYMgLIMC-mAyQzLrhCA0fKAEgyADgyAWP8vMf90axQFR0ZBqfioIzICApTBYCAAbyIUDocjouGQAC4IJY6GoVABzZEQdDISxGfEAB1ROGxuPx2CJUAAvi8jDhcRA6HDMNiALL4eJaZKwrBpCAAXkRxNR6KxEAARAAJCwKgA0xNJ5KpNOw2IV-EwelQagVRFZRG5WAAdLKMZLFSrcLhMAqIMBgBAAKJqNSYNTYox8bCYOgQDSoSyWOQE1SocOaRJUSl+ylguiEFE861ailyalyHAOhXkE0sI1uj3e33+wPB0MJyPR2MQeMR4XJ1PpzMQf4xF7igDiaKVbHIV0AXR6AWKjxt8GHQ6JTLJiPYCjAxrfpLNb-QTgNBgPpUGAQMAbKAIAB9a83283iCAZQYH8NAM0MwUAkwyZQAYUYBTRSvd4Ay8IFPGwMzTCABSFJNUggZAAA9QWwdBLAgPRDBMcUpSRKB2yTCAAG0AAUIBUCBzHwTB+BhABdbEUiI6iwAtC9AIAiBQkAToZAAmGQBGhmCDj-1Y+8QLkABbSl-TDMDoQRb0AEc2FQXA1W9OC0xMCBmQgfg-VEiAAHJuGkuB1yUjFGTJYA2FRXBLH00D8HAoNLDJB18KIL01OMOgki9BSlKSSDE20VIeQARjSFSoJC0VMAitJIrARiwBBMEIShGFwulFE0QxOk8UJIhcx1Qs9RxArGSIdlxIxUF0GxcgjQxPgiFE5A6FQbFsKgVtrKYANyoZJlNKY88QEEoSgMAQmtfA40JAGGGRoJqE4Cz1AIhxUAY8jABVvTJAEdFQBIc1nedF2XVdyQ3LcdzUPcDz4SwAHcwUPY8oC23bAGjIsY5wXJcV2ANdLu3Xd92ASxMFwazSqBCBxUAXQZfEANblfEAJqjABkMn7Tv+wHN2Bm6XpPM8gA)
```typescript
type MyReadonly<T extends object> = {
  readonly [P in keyof T]: T[P]
}
```

`T`がオブジェクトで、`T`の全てのプロパティを反復処理して、そのプロパティ名を`P`とします。これを`readonly`としてマークして`T[P]`で元の型をペアにしました

#### [readonly](https://typescript-jp.gitbook.io/deep-dive/type-system/readonly)
インターフェース上のプロパティを`readonly`としてマークすると、そのプロパティを読み取り専用にできる

```typescript
interface Todo {
  readonly title: string
  description: string
}

const todo: Todo = {
  title: "Hey",
  description: "foobar"
}


todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // OK
```