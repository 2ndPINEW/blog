{
  "title": "1日1TypeChallenges",
  "description": "1日1TypeChallengesして、型の理解を深めます",
  "icon": "/assets/Typescript_logo_2020.png",
  "date": "2023/01/18",
  "tags": ["TypeChallenges", "TypeScript"]
}
---metadata

## Pick
オブジェクトから特定のプロパティを抽出する型です

#### 使い方例
```typescript
interface A {
  a: string
  b: number
}

type t0 = Pick<A, 'a'>
// { a: string }
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsELQQAoEsDGBrS8491gRgJ4QCCAdgC4AWA9mcQGICuEAFAAICGlAZkwJQQAxIFwlQFi+wpmWR1h+JsgA2FOMjJgsQrREBXMYHlVDVEAivoH8GQD3xJwHYMgaPVAZwyAfhkBjDIGKGQFcMLgAYoMAHgAqADQQANIAfB6ASQyA-vKAFK6A2gyAWgyAgAwefh6A0gyAkQwewR6WgOsMgLcMgIsMLhGAvUaAX4qAmgyA0QzWEYD52oCjEYDqDIB+DNWAQAyGEIDR8oASDIAODIBY-70eExQAzlhqFACmAE48nKjzEH40ACY0EADeWFAUyBSK8wBcEFMUi2oA5ocQW-NTqLcADsd0l9e3ZA9QKCoGgAW3eZwWW0u+BoNDO3CwAF9ehRCO91psdohFvMAG7IeYAdwgAF4IABZQjedD+bY0IIAcmOp3mDIgAB8IAzgWCIfMtgzQr1gWRrhAKHTLpiaNi8QTiWSDoDAcyzpcGQBheFkCCLWEghkBR5A0Hg+aQy4rRRTeZGqDIqATDy9UIQADiJwAEkx8IBzBkAXR6AWKi6iMqBQKO8pudgMBpqgqAA6ABWUwTNEWd2A0GASc4YBAwA0oAgAH0y+WK+WIIBlBmrgGsGQDNDPZAJMMEUAGFGAU0VS5WeyWIAWNHMlis1qR9lhOD8bvcCJcyEwQfglmBkWBUejxQAGUlINA0kiMziCjTr9YUACMO-Q80INB4pBPaPWlOp-gg8wAHgsyFsphAaPgSbzKgFBBME75fvMP5-tet73n4rqKlgADaiAQGoIQALpSqhmErkWIDdr2FYQI4gCdDIAEwyAI0M9hkURxFlv2hbIGC6YUOKT77BAACiACOTCcIoQTcR+6IgRAiIQDweogly7CnnA8aCWc-wvMATDHNaDKPhuqCcDaf5kshWAiWJFA+HxAmKBZonAZC55BC+e60jsjKqqyoSeXaPG2SBFn8YJNlmfyABMjlUs50puScZxspy3KmnyAqeaE3kxhA8lTHAn5mdlix6osWBOb4UVcu5cVcjyZqQhVDJqLignIMlRp4WAQ7LKsGJ0uORwxRcVzTv8WDPK8HxfGQU5-ACEBVUl0Kwtq+FtZQw6dT5wVbJeSrin1k0zqu7Ujuspl2aFPU7Sye1DSavLmvy81wvMCKrsWDEkYAhNaWGRjiAMMM+T0QxTFgKAWCuoAx5GACreESAI6KgCQ5iGYYRlGMZxomKZphmWbANwUyEksOZ5lA4NQ4A0ZG1KG4aRtGsavGjqbppm2ZTHCGkyKKoMQIAugyWIAa3KWIATVGADIZFNI9TqPJvTmO5vmhZAA)

```typescript
type MyPick<T extends object, K extends keyof T> = {
  [P in K]: T[P]
}
```
`<T extends object, K extends keyof T>`で、引数Tがオブジェクト、引数KがTのプロパティ名をユニオン型で持つ必要がある物として定義します。

`[P in K]: T[P]`の部分が、Kを反復処理して、Pにそれぞれのプロパティ名が入るので、`T[P]`でプロパティの元の型を取り出します

#### [keyof](https://typescriptbook.jp/reference/type-reuse/keyof-type-operator)
オブジェクト型からプロパティ名を型として返す型演算子。
プロパティ名が2つ以上ある場合は全てのプロパティ名がユニオン型で返る。

```typescript
interface A {
  a: string
  b: number
}

type t1 = keyof A
// 'a' | 'b'
```

#### [extends(型引数の制約)](https://typescriptbook.jp/reference/generics/type-parameter-constraint)
型引数にextendsキーワードを用いることで、ジェネリクスの型Tを特定の型に限定することができる

以下の例では、`T`が`HTMLElement`であることが保証される
```typescript
function changeBackgroundColor<T extends HTMLElement>(element: T) {
  element.style.backgroundColor = "red";
  return element;
}
```

#### [Mapped Types](https://typescriptbook.jp/reference/type-reuse/mapped-types)
`in`がユニオンで与えられた値をforみたいに反復処理するイメージ

```typescript
type SystemSupportLanguage = "en" | "fr";
type Butterfly = {
  [key in SystemSupportLanguage]: string;
};
// { en: string, fr: string }
```

## Readonly
`T`の全てのプロパティを読み取り専用にする型です

#### 使い方例
```typescript
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBDsELQQEoFMCGATA9gOwDYE9J44TSiAjfCAQWwBcALHKgMQFcIAKAAVXoDM2ASggBiQLhKgLF8x5NgEtcdOHOxiATmix4qozOQBWyAMZKA1snwBnMEVF2IgK5jA8qo2ogEV9A-gyAe+I+A7BkDR6oBnDIA-DIBjDIDFDIBXDBEABigYOAQAPAAqAHwxgEkMgP7ygBSugNoMgFoMgIAMMSkxEL6AmgyAngyAZgy+gOsMgLcMgIsMEZmAtVEegGvKgFEMgEA6uYDWDFWA0Qz+mYD52oCjEYDqDIB+DFWAQAyzgKoMgDEMgPoM-k1tEYD2DICxioBOSn2Ayvp1gOYMgLIMC-mAyQzLrhCA0fKAEgyADgyAWP8vMf90axQFR0ZBqfioIzICApTBYCAAbyIUDocjouGQAC4IJY6GoVABzZEQdDISxGfEAB1ROGxuPx2CJUAAvi8jDhcRA6HDMNiALL4eJaZKwrBpCAAXkRxNR6KxEAARAAJCwKgA0xNJ5KpNOw2IV-EwelQagVRFZRG5WAAdLKMZLFSrcLhMAqIMBgBAAKJqNSYNTYox8bCYOgQDSoSyWOQE1SocOaRJUSl+ylguiEFE861ailyalyHAOhXkE0sI1uj3e33+wPB0MJyPR2MQeMR4XJ1PpzMQf4xF7igDiaKVbHIV0AXR6AWKjxt8GHQ6JTLJiPYCjAxrfpLNb-QTgNBgPpUGAQMAbKAIAB9a83283iCAZQYH8NAM0MwUAkwyZQAYUYBTRSvd4Ay8IFPGwMzTCABSFJNUggZAAA9QWwdBLAgPRDBMcUpSRKB2yTCAAG0AAUIBUCBzHwTB+BhABdbEUiI6iwAtC9AIAiBQkAToZAAmGQBGhmCDj-1Y+8QLkABbSl-TDMDoQRb0AEc2FQXA1W9OC0xMCBmQgfg-VEiAAHJuGkuB1yUjFGTJYA2FRXBLH00D8HAoNLDJB18KIL01OMOgki9BSlKSSDE20VIeQARjSFSoJC0VMAitJIrARiwBBMEIShGFwulFE0QxOk8UJIhcx1Qs9RxArGSIdlxIxUF0GxcgjQxPgiFE5A6FQbFsKgVtrKYANyoZJlNKY88QEEoSgMAQmtfA40JAGGGRoJqE4Cz1AIhxUAY8jABVvTJAEdFQBIc1nedF2XVdyQ3LcdzUPcDz4SwAHcwUPY8oC23bAGjIsY5wXJcV2ANdLu3Xd92ASxMFwazSqBCBxUAXQZfEANblfEAJqjABkMn7Tv+wHN2Bm6XpPM8gA)
```typescript
type MyReadonly<T extends object> = {
  readonly [P in keyof T]: T[P]
}
```

`T`がオブジェクトで、`T`の全てのプロパティを反復処理して、そのプロパティ名を`P`とします。これを`readonly`としてマークして`T[P]`で元の型をペアにしました

#### [readonly](https://typescript-jp.gitbook.io/deep-dive/type-system/readonly)
インターフェース上のプロパティを`readonly`としてマークすると、そのプロパティを読み取り専用にできる

```typescript
interface Todo {
  readonly title: string
  description: string
}

const todo: Todo = {
  title: "Hey",
  description: "foobar"
}


todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // OK
```

## TupleToObject
タプルを受け取り、その各値のkey/valueを持つオブジェクトの型に変換する型を実装します。

#### 使い方例
```typescript
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCM0QtBAKgVwA4BsCmEAuB7CAeQCMArLAY10gXnodpIE8IBnASwDt98uIAFAAFOPPgEoIAYkC4SoCxfafnJVc8ANZZmbMLSl6IgK5jA8qo6ogfoZA6wyBrhkBJDIHXlQIoMgNeVAUQyBABkC6DIDsGQCAqgEgUvDWZgADcAQwwULBtAQGNAEwZAKoZANYZADoZAcoZAeoZACYYvQGj1QGsGQEhNQG3jQE0GQGiGXJtAfO1AUYjAdQZAPwZSwCAGUwhAaPlACQZABwZALH-2gANh3G0oSj42XDx0bAgAXggAbQByXCw2DDCVgBoIFYBbfAATLAwIAGZd-aPT84ANa8OTs4gATRWAXQgwtggJrhTdq4ZhoHAAJw2KAw00WqEwWCQ+FIFGoAB4QWD8AAzGYIgB8EGAwAgWAAHmDqFhjhAAN54DZbABc+3Wm22e2ed0uKxZXNeV05t1ejz5woeT3F715Nxe5w+AF9aMNBu1CQBxDi4AASKBIgHMGQBdHoBYqIqfQAFrhcGg2EziaNKOaAHRkNhO-DggDmwFgwDIYTAIGAOlAEAA+hHI1HIxBAMoMsfygGaGQA-DIBJhhsgAwowCmiuHo3mwxAg2BMTh4dgkSiVGikKSyesuMc-pCwsc+BhWGEuMwlp9CYs6bQlgAFCDcZBLLgoA4kLDgz6fFlDsBK4ugnCw5CzRHI5Toks4vHYfEhkC5-NRiCAMYZAJ0MWUAjQzJ69n88RwvBjgHNAe6YlukQACiACOKARHs-4UioEAKhA2LgvgBz7EIJbwI6ETYFwnobMAKC4BwGBsCsOgAlMh44IsqxslskpyjyQo0Y8dHch83y-P8kw0MRP5bgAclOM7ggsyzQHsABMewXHsAAsLF-JxYCcaRACyHBkoJSzCfsInXBJ+ySV8PyyexOi-pQvwbGptDgZSuBokBIEYNWW4VruNn7riuBbviez0pRYR8r5KwANyytyVxijRVzBfyErhdyjxRVKHyxa8HxQfiXmWRB6J2REjkIs5qKuWuB4eQivHTrOXl-tALLQMFIksiJwUXCyFzBZJLKSWlGVQFZVY5Q5ZbbpWe7Fe5W7KWSVX0jVMBRVpfJac1rVRXpfJ6d1OxgJ8IYkkhbDwOS1mHeCcHgquYKkqdHqCUNBVVks6miZ83kKr2J7Pi+ECAITWXjXpegDDDBYn3nm+YCgLQhKAMeRgAq3jYgCOioAkOZmpa1q2vabCOi6boet6vqdmwADus5+gGUDQ3DgDRkeUFpWjadrAA6zquu6Xo+tAwBsPgkS4ZMkMQN4gBrcl4gBNUYAMhm02jDNM9jrPev6gbBkAA)
```typescript
type TupleToObject<T extends readonly any[]> =  {
  [P in T[number]]: P
}
```
`Tuple`で渡された型を、`T[number]`でユニオンにして、`in`でプロパティ名と値として展開した

#### [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
別の型の特定のプロパティを検索できる(これは今までも使ってた)
```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
// expected number
```

配列の要素の型を取得するのに`number`も使えるらしい。覚えとくと便利そう
```typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
]
 
type Person = typeof MyArray[number];
// type Person = {
//   name: string;
//   age: number;
// }
```

## TupleToUnion
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAMEFoIBUCuAHANgUwgFwHsIBVAOwEsDTJEE76aAjATwgEFS8ALK1gMVQQAFAAEAhpwBmqAJQQAxIFo5QFi+C8qUnYATgrwYcC1BSpga88xEBXMYHlVU1ED9DIHWGQNcMgOwZAJAqBpBkCRDIDOGQNMMgFUMgM8MgNHqgEkMgPiugAhGgJoMgNEMAAZoWNjIBGSUpAA8yAB8ieGA+dqAoxGA6gyAfgyxgEAMdhCA0fKAEgyADgx1ie14AM40eMzouGxaOgC8EADaAOTQEwA0EBMATLPzAMwTALp1vf0o2J14EKMpOOmZVNmDWnkQwMAQ2AAe-QDGeNgAJvhEjLhTExAAH3mS0BqwmNHaiTq1wA4uQ8AAJVCMQDmDIAuj0AsVEJQBY-1w8Hh0J0AFy3LrPLgAOgAVp0KQQtABzYBwYBUsRgEDAUygCAAfX5AsFAoggGUGEWAawZAM0MgB+GQCTDOFABhRgFNFPlCtW8iCc0zbXDHNIZYw5fKHFD3B5vUjvTrsIZiZjZdSaHTEa4AfhIECJEFI2AAbtpuSBVerBRBAGMMgE6GQATDIBGhmlEeDIf5mq55AAtuh6QcdRAAN4QACiAEdUGJMHMC09sK8IABfCCSLQENPzEQ6hDkss4UgMvbAVB4ciYTrgsA555iTp7E1jGiVl54bLF0uYXL6fVnHJjaALFZzCYAFgArAA2ZZ4LSobDrPJzHcrUGH0--IEXq95W9zquvJclstr1JTkNbJt13G8713D8ZjATYwB5JNQ0AQmtXAjMNAGGGRxEyTFM4PAKBrkAY8jABVvcJAEdFQBIcxxPECWJUlOnJalaXpJkWQkToAHdtFZdl8IgYjwkAaMj4lxfFCRJYAyUpGk6UZZlYGAToCEwAcsm6XjAF0GVxADW5VxACaowAZDJEmjxMkxiZKZNkOS5IA)


## DeepReadonly
オブジェクトの全てのパラメータと、そのサブオブジェクトを再帰的に読み取り専用にする

#### 使い方例
```typescript
type X = {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

type Expected = {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCcELQQCIFNkAcICVkEMAmA9gHYA2AnpPHNTZQEZkQCCRALgBbGMBiArhAAoAAjjYAzXgEoIAYkC0coCxfWQCdchUoxkE6AK2QBjVnADWyMgGdZeVGjCUZDiICuYwPKqdqICqGQGsMgDoZA5QyA9QyAEwyAdgyAmgyAngyAZgwhgIsMgJcMgIcMgD8MgP0MyYAQ-4BSDIARDIDODIC6DCGArQxe3v7BgEkMgLGKgAx6gCFugNYMgJD-lYC1UYD+DIBryoBRDIBAOoAUro1hgNEMAAYo6Nj4xOQAPAAqAHxjlYD52oCjEYDqDIB+DGGAQAzuEIDKDCGATVGAMhmA5gyA9gzlgaEdlYCORoDGDFGAIgwjgBYMgM8GgFnaWyigHkGQAGDIBVBg++0AsomAdCVAIAMgCLUwAOpvCAvFAJ0MgCsGQCWDDdAMABgDtDUaAUf1AIGRN0AQgw9HaAbQZAMkM+y2gGkGLbwwD3yoBfgKxgAU0nqADctAKAMWMAjQzJDGVQDVDIAFhmSo2O3yu8MAV4GAMCVlYBquMagERjQBkRvLvoAZBiugFkGPaHSiAaPlABIMgAcGI5jR2scyUVhkNDICAADQgAF4IABvShQAAeAC5A8GoBAcBGAIxRqB0CMAcnYAEsU1GAL5Rsip9hmLNQXOu92egCiIY9hmQeD9kejEFUMw0EHDjabzbUs0YsYgCa73db5AgyYgaczOajLfUo-zE8LZGLEFLUDdHogCwIhAbkzQ0znZDmXqWEGAwAg5k4vBI9bonvMOAAtp6cJYxlWa6w62NKI6-0oM8AHF01YAAJXg6CuQAuj0AWKjRkALH-2FYVg0HMMML2dfR2AAOh0cxcIIZQAHNgGgYAdBwMAQGAOxQAgAB9ZiWNYliTmORpAGaGZJAEmGSpAAwowBTRSYtixMYiBaLsDdPX3Q9e0WM9-SDKBZ17CAAG0AAUIHTIgIFMMgCDELcAF0IwWbTTIgZAQx-Ig8EsPgiEMdNiAgAB+LcrIgCM5J7DRFispYwFLBjxLEiBADGGDEgjFDFRIi9ipPTZ80GI1gIBkwMIArABHXgcBIAAaXLqwMTLswgMRlAIZ8JyEGS4BwoqSGQIgSOQcxgF4Vh0xIcwszAbL9HfLqGw0ygvwquZ8sKkg5n8kdjy9OMllK6bazwNb1qm8rDFmgqisWmx5MCr0ACZ1rK786yu3bTOk8tvTjBsVJjCMBGkX0zwui76AjcxWGUPSSMofQI3eqA8AjOgCAINrRCjZBIcTCASNRocoHYTGsagdMI2B3hkDRpsdFTIGQY6lch1zPHjALZASBIAgaejOmuxICNJrxycU2K0nOzx59ubTItHrx7MBaHCX2coXNS2yy63o+q9gdB1cIAAHxy8ciF4Z8H2UVcns3Taf22t7KDUtt+y+v1fv+1SAtHcdKdB62XcYCGheHI8IBhsd4cRogZy9mzcabG3Rwx32o-DnG467aPGAJrLlGJwXneWiByYnd3qcFjmhxTgzGeZ1m0eL6NS65v31J5rG+elrGoax0uRfrtsNLF5dZdplum37k2S1C03K32i2LpV0v+wLkjNZ1gMu9diN9cN5BjbCkBEqSiTAEJrEIMSiwBhhkAdYZd6SyS6NAICIEAY8jABVvSpAEdFQBIcyQlC0IwrDzBw-DCLETIhRUQ5gADum9KLUSgGeJ+lRADRkSMZCqF0KYWANhPCBEiKkXIsAcwCNepuSIC6GBEAiiADW5c4FxkHfzQRggB2CyJURonRIAA)
```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : DeepReadonly<T[P]>
}
```
前回作った、`Readonly`を拡張て、`T[P]`が関数の時はそのまま、違った場合は再帰的に`T[P]`を`DeepReadonly`します

`T`が`string`の時、`string`になるのなんで🤔
```typescript
type DeepReadonly<T extends object> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : T[P] extends object ? DeepReadonly<T[P]> : T[P]
}
```
最初こうしてた

#### [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)