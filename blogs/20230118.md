{
  "title": "1日1TypeChallenges",
  "description": "1日1TypeChallengesして、型の理解を深めます",
  "icon": "/assets/Typescript_logo_2020.png",
  "date": "2023/01/18",
  "tags": ["TypeChallenges", "TypeScript"]
}
---metadata

## Pick
オブジェクトから特定のプロパティを抽出する型です

#### 使い方例
```typescript
interface A {
  a: string
  b: number
}

type t0 = Pick<A, 'a'>
// { a: string }
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsELQQAoEsDGBrS8491gRgJ4QCCAdgC4AWA9mcQGICuEAFAAICGlAZkwJQQAxIFwlQFi+wpmWR1h+JsgA2FOMjJgsQrREBXMYHlVDVEAivoH8GQD3xJwHYMgaPVAZwyAfhkBjDIGKGQFcMLgAYoMAHgAqADQQANIAfB6ASQyA-vKAFK6A2gyAWgyAgAwefh6A0gyAkQwewR6WgOsMgLcMgIsMLhGAvUaAX4qAmgyA0QzWEYD52oCjEYDqDIB+DNWAQAyGEIDR8oASDIAODIBY-70eExQAzlhqFACmAE48nKjzEH40ACY0EADeWFAUyBSK8wBcEFMUi2oA5ocQW-NTqLcADsd0l9e3ZA9QKCoGgAW3eZwWW0u+BoNDO3CwAF9ehRCO91psdohFvMAG7IeYAdwgAF4IABZQjedD+bY0IIAcmOp3mDIgAB8IAzgWCIfMtgzQr1gWRrhAKHTLpiaNi8QTiWSDoDAcyzpcGQBheFkCCLWEghkBR5A0Hg+aQy4rRRTeZGqDIqATDy9UIQADiJwAEkx8IBzBkAXR6AWKi6iMqBQKO8pudgMBpqgqAA6ABWUwTNEWd2A0GASc4YBAwA0oAgAH0y+WK+WIIBlBmrgGsGQDNDPZAJMMEUAGFGAU0VS5WeyWIAWNHMlis1qR9lhOD8bvcCJcyEwQfglmBkWBUejxQAGUlINA0kiMziCjTr9YUACMO-Q80INB4pBPaPWlOp-gg8wAHgsyFsphAaPgSbzKgFBBME75fvMP5-tet73n4rqKlgADaiAQGoIQALpSqhmErkWIDdr2FYQI4gCdDIAEwyAI0M9hkURxFlv2hbIGC6YUOKT77BAACiACOTCcIoQTcR+6IgRAiIQDweogly7CnnA8aCWc-wvMATDHNaDKPhuqCcDaf5kshWAiWJFA+HxAmKBZonAZC55BC+e60jsjKqqyoSeXaPG2SBFn8YJNlmfyABMjlUs50puScZxspy3KmnyAqeaE3kxhA8lTHAn5mdlix6osWBOb4UVcu5cVcjyZqQhVDJqLignIMlRp4WAQ7LKsGJ0uORwxRcVzTv8WDPK8HxfGQU5-ACEBVUl0Kwtq+FtZQw6dT5wVbJeSrin1k0zqu7Ujuspl2aFPU7Sye1DSavLmvy81wvMCKrsWDEkYAhNaWGRjiAMMM+T0QxTFgKAWCuoAx5GACreESAI6KgCQ5iGYYRlGMZxomKZphmWbANwUyEksOZ5lA4NQ4A0ZG1KG4aRtGsavGjqbppm2ZTHCGkyKKoMQIAugyWIAa3KWIATVGADIZFNI9TqPJvTmO5vmhZAA)

```typescript
type MyPick<T extends object, K extends keyof T> = {
  [P in K]: T[P]
}
```
`<T extends object, K extends keyof T>`で、引数Tがオブジェクト、引数KがTのプロパティ名をユニオン型で持つ必要がある物として定義します。

`[P in K]: T[P]`の部分が、Kを反復処理して、Pにそれぞれのプロパティ名が入るので、`T[P]`でプロパティの元の型を取り出します

#### [keyof](https://typescriptbook.jp/reference/type-reuse/keyof-type-operator)
オブジェクト型からプロパティ名を型として返す型演算子。
プロパティ名が2つ以上ある場合は全てのプロパティ名がユニオン型で返る。

```typescript
interface A {
  a: string
  b: number
}

type t1 = keyof A
// 'a' | 'b'
```

#### [extends(型引数の制約)](https://typescriptbook.jp/reference/generics/type-parameter-constraint)
型引数にextendsキーワードを用いることで、ジェネリクスの型Tを特定の型に限定することができる

以下の例では、`T`が`HTMLElement`であることが保証される
```typescript
function changeBackgroundColor<T extends HTMLElement>(element: T) {
  element.style.backgroundColor = "red";
  return element;
}
```

#### [Mapped Types](https://typescriptbook.jp/reference/type-reuse/mapped-types)
`in`がユニオンで与えられた値をforみたいに反復処理するイメージ

```typescript
type SystemSupportLanguage = "en" | "fr";
type Butterfly = {
  [key in SystemSupportLanguage]: string;
};
// { en: string, fr: string }
```


## Readonly
`T`の全てのプロパティを読み取り専用にする型です

#### 使い方例
```typescript
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBDsELQQEoFMCGATA9gOwDYE9J44TSiAjfCAQWwBcALHKgMQFcIAKAAVXoDM2ASggBiQLhKgLF8x5NgEtcdOHOxiATmix4qozOQBWyAMZKA1snwBnMEVF2IgK5jA8qo2ogEV9A-gyAe+I+A7BkDR6oBnDIA-DIBjDIDFDIBXDBEABigYOAQAPAAqAHwxgEkMgP7ygBSugNoMgFoMgIAMMSkxEL6AmgyAngyAZgy+gOsMgLcMgIsMEZmAtVEegGvKgFEMgEA6uYDWDFWA0Qz+mYD52oCjEYDqDIB+DFWAQAyzgKoMgDEMgPoM-k1tEYD2DICxioBOSn2Ayvp1gOYMgLIMC-mAyQzLrhCA0fKAEgyADgyAWP8vMf90axQFR0ZBqfioIzICApTBYCAAbyIUDocjouGQAC4IJY6GoVABzZEQdDISxGfEAB1ROGxuPx2CJUAAvi8jDhcRA6HDMNiALL4eJaZKwrBpCAAXkRxNR6KxEAARAAJCwKgA0xNJ5KpNOw2IV-EwelQagVRFZRG5WAAdLKMZLFSrcLhMAqIMBgBAAKJqNSYNTYox8bCYOgQDSoSyWOQE1SocOaRJUSl+ylguiEFE861ailyalyHAOhXkE0sI1uj3e33+wPB0MJyPR2MQeMR4XJ1PpzMQf4xF7igDiaKVbHIV0AXR6AWKjxt8GHQ6JTLJiPYCjAxrfpLNb-QTgNBgPpUGAQMAbKAIAB9a83283iCAZQYH8NAM0MwUAkwyZQAYUYBTRSvd4Ay8IFPGwMzTCABSFJNUggZAAA9QWwdBLAgPRDBMcUpSRKB2yTCAAG0AAUIBUCBzHwTB+BhABdbEUiI6iwAtC9AIAiBQkAToZAAmGQBGhmCDj-1Y+8QLkABbSl-TDMDoQRb0AEc2FQXA1W9OC0xMCBmQgfg-VEiAAHJuGkuB1yUjFGTJYA2FRXBLH00D8HAoNLDJB18KIL01OMOgki9BSlKSSDE20VIeQARjSFSoJC0VMAitJIrARiwBBMEIShGFwulFE0QxOk8UJIhcx1Qs9RxArGSIdlxIxUF0GxcgjQxPgiFE5A6FQbFsKgVtrKYANyoZJlNKY88QEEoSgMAQmtfA40JAGGGRoJqE4Cz1AIhxUAY8jABVvTJAEdFQBIc1nedF2XVdyQ3LcdzUPcDz4SwAHcwUPY8oC23bAGjIsY5wXJcV2ANdLu3Xd92ASxMFwazSqBCBxUAXQZfEANblfEAJqjABkMn7Tv+wHN2Bm6XpPM8gA)
```typescript
type MyReadonly<T extends object> = {
  readonly [P in keyof T]: T[P]
}
```

`T`がオブジェクトで、`T`の全てのプロパティを反復処理して、そのプロパティ名を`P`とします。これを`readonly`としてマークして`T[P]`で元の型をペアにしました

#### [readonly](https://typescript-jp.gitbook.io/deep-dive/type-system/readonly)
インターフェース上のプロパティを`readonly`としてマークすると、そのプロパティを読み取り専用にできる

```typescript
interface Todo {
  readonly title: string
  description: string
}

const todo: Todo = {
  title: "Hey",
  description: "foobar"
}


todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // OK
```


## Tuple To Object
タプルを受け取り、その各値のkey/valueを持つオブジェクトの型に変換する型を実装します。

#### 使い方例
```typescript
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCM0QtBAKgVwA4BsCmEAuB7CAeQCMArLAY10gXnodpIE8IBnASwDt98uIAFAAFOPPgEoIAYkC4SoCxfafnJVc8ANZZmbMLSl6IgK5jA8qo6ogfoZA6wyBrhkBJDIHXlQIoMgNeVAUQyBABkC6DIDsGQCAqgEgUvDWZgADcAQwwULBtAQGNAEwZAKoZANYZADoZAcoZAeoZACYYvQGj1QGsGQEhNQG3jQE0GQGiGXJtAfO1AUYjAdQZAPwZSwCAGUwhAaPlACQZABwZALH-2gANh3G0oSj42XDx0bAgAXggAbQByXCw2DDCVgBoIFYBbfAATLAwIAGZd-aPT84ANa8OTs4gATRWAXQgwtggJrhTdq4ZhoHAAJw2KAw00WqEwWCQ+FIFGoAB4QWD8AAzGYIgB8EGAwAgWAAHmDqFhjhAAN54DZbABc+3Wm22e2ed0uKxZXNeV05t1ejz5woeT3F715Nxe5w+AF9aMNBu1CQBxDi4AASKBIgHMGQBdHoBYqIqfQAFrhcGg2EziaNKOaAHRkNhO-DggDmwFgwDIYTAIGAOlAEAA+hHI1HIxBAMoMsfygGaGQA-DIBJhhsgAwowCmiuHo3mwxAg2BMTh4dgkSiVGikKSyesuMc-pCwsc+BhWGEuMwlp9CYs6bQlgAFCDcZBLLgoA4kLDgz6fFlDsBK4ugnCw5CzRHI5Toks4vHYfEhkC5-NRiCAMYZAJ0MWUAjQzJ69n88RwvBjgHNAe6YlukQACiACOKARHs-4UioEAKhA2LgvgBz7EIJbwI6ETYFwnobMAKC4BwGBsCsOgAlMh44IsqxslskpyjyQo0Y8dHch83y-P8kw0MRP5bgAclOM7ggsyzQHsABMewXHsAAsLF-JxYCcaRACyHBkoJSzCfsInXBJ+ySV8PyyexOi-pQvwbGptDgZSuBokBIEYNWW4VruNn7riuBbviez0pRYR8r5KwANyytyVxijRVzBfyErhdyjxRVKHyxa8HxQfiXmWRB6J2REjkIs5qKuWuB4eQivHTrOXl-tALLQMFIksiJwUXCyFzBZJLKSWlGVQFZVY5Q5ZbbpWe7Fe5W7KWSVX0jVMBRVpfJac1rVRXpfJ6d1OxgJ8IYkkhbDwOS1mHeCcHgquYKkqdHqCUNBVVks6miZ83kKr2J7Pi+ECAITWXjXpegDDDBYn3nm+YCgLQhKAMeRgAq3jYgCOioAkOZmpa1q2vabCOi6boet6vqdmwADus5+gGUDQ3DgDRkeUFpWjadrAA6zquu6Xo+tAwBsPgkS4ZMkMQN4gBrcl4gBNUYAMhm02jDNM9jrPev6gbBkAA)
```typescript
type TupleToObject<T extends readonly any[]> =  {
  [P in T[number]]: P
}
```
`Tuple`で渡された型を、`T[number]`でユニオンにして、`in`でプロパティ名と値として展開した

#### [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
別の型の特定のプロパティを検索できる(これは今までも使ってた)
```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
// expected number
```

配列の要素の型を取得するのに`number`も使えるらしい。覚えとくと便利そう
```typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
]
 
type Person = typeof MyArray[number];
// type Person = {
//   name: string;
//   age: number;
// }
```


## First of Array
#### 使い方例
配列`T`を受け取り、その最初のプロパティの型を返す`First<T>`を実装します。

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAsEFoIDECWAnAzgFwgewDMIBBddAQwE9JEE76aAjSkgO2wAs9WXkBXCAAoAAuXYE+ASggBiQLhKgLF9Z5MlTA0ZmiICuYwPKq6qIFlEwOhKAAwAqpwEkMgdeVAigyA15UBRDIEAGQLoMgOwZAAOZyPgdYZAW4ZARYZAMYZAYoYPQGj1K0AV+MBNBlM0LGwAHnMAPmtAfO1AUYjAdQZAPwY4wCAGAwhAaPlACQZABwZALH+y00bsTBpsSgAHAFMIFXRoCABeCABtAHJyUYAaCFHGKZmAY1GAXVaO7t6AJkGRgGZpzenoVbWuiA5O8gATfqGknBTe6HSIYGAIToAPLoXsTquINg8BBGN1xqNTt0LtdtncMA8ti83h9vp1fv9AcDQRBdjRGqYyi8AOKobAACT4jEA5gyALo9ALFRcUA0Qy1DjYbDtTAALjezQWHAAdAArTD8vDoADmwDgwEF5DAIGA6lAEAA+mr1Rr1RBAMoM2sA1gyAZoZAD8MgEmGKyADCjAKaKqs1tpVEAVYDaZ3uqXMKL+rCumB6PGGyxeQ3dX093pGYko0350Yj-uWEAA-BBzMMAAzxzkQVidABunXQSpANrtGogIUAnQyACYZAI0MRvLxZLaoditQAFt2mLcM7ugBvCAAUQAjnxyAAbab91G-CAAXwgBHQeFbM2E3YQfLHo86rHFnUwwD42FQo8wEKd6wgC3ImD3O2GNEnP1SQ5Ho5SrpSw32EEOMAD012dJ0kmB8p2fYcx3feFUmGQRpAGF5oE2b8+3ITMcHQVAd1nf8hHgxDkKAkCoEfNFwNfKDkk-XDszzdAiNAp8UhfSCP2GPgvU6AgsP+XCOKuLieKuBiTm7D4yDFH0hnvKBkVXTAEC+J9FIkgsoA-UZWDwbBSAoShRmAmg5OaRSwJUxc1JQaCUj7VNM3GVRKAAGVQABrTpRlnQyTmVRtS0AQmsPHLEJAGGGPwG0bZswFAGgXkAY8jABVvKxAEdFQBIcyZFk2Q5blgF5AVhVFCUpVgYAxEwAB3fMZTlKB4qSwBoyOZVl2S5HlMD5IURTFSVpUwPBR0PVBuBaWqIE8QA1uQ8QAmqMAGQzMpanK8s6wrJVleVFSAA)

```typescript
type First<T extends any[]> = T extends [any, ...any[]] ? T[0] : never
```
`T`が要素数1以上の配列なら`T[0]`を返すようにしました

他の回答見てたら`T extends [infer first, ...any[]]`ってしてるのがあった。こっちの方が賢そう

#### [スプレッド演算子](https://typescript-jp.gitbook.io/deep-dive/future-javascript/spread-operator)
Firstの実装ではスプレッド演算子の、分割を使った
```typescript
var [x, y, ...remaining] = [1, 2, 3, 4];
console.log(x, y, remaining); // 1,2,[3,4]
```

#### [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
型の条件分岐を行います
```typescript
// `T`が`U`に割り当て可能なら`T`、割り当て不可能なら`U`になる型
type A<T, U> = T extends U ? T : U
```


## Length of Tuple
タプルTを受け取り、そのタプルの長さを返す型Length<T>を実装します。

#### 例
```typescript
type tesla = ['tesla', 'model 3', 'model X', 'model Y'] as const
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] as const

type teslaLength = Length<tesla>  // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAcEFoIBkCmA7A5gFwBYQHsAzCAFQFcAHAG1UkQUafoCMBPCAZwEt0CD0EABQABHnwEBKCAGJAuEqAsX1nYqtMPRmaIgK5jA8qrqogfoZA6wyBrhgAGpc4CSGQOvKgRQZAa8qAohkCADIF0GQHYMJ058DuqYCqDNaAK-GAmgyA0ermaFh4ADykAHw2gPnagKMRgOoMgH4MoYBADAYQgNHygBIMgA4MgFj-+eZV2Jz02GyUqBDYqJzUAIYQALwQANoA5C1t7f0ANBD9ALYEACao1BAAzGMT03MLABorU7PzEACa-QC6dQ1NnJTtAMaoG919-QBiAILIAMIA8gByEACc2y93t8IAAJACizwAaodxv0ACIAJWeAHFvtsAMqkZ4I9EggCSAAVtiCAKoAWWeP3RBOebzBj2QeORINIx3y9UazVaHWiOHwPV5cSGHQSUGAwAgqAAHo0ri0ZhAACynTkXa63QX8lAYPmxNU3Dai8WSmWoOWoBUAVnoVXM+VFyO42BB5BYgHMGQBdHoBYqNCgGiGMq4bDYSicABc4pqV1wADoAFacaMEABOmGAcGAsfaYBAwHUoAgAH0i8WS8WIIBlBnLgGsGQDNDIAfhkAkwzWQAYUYBTRULpc7BYgOfUHKamviJpa6BmnAgSdQ7RmAmoHHa6DYvSOop6pAGtBiuDZYHzXc7EEAYwyAToZABMMgEaGOvHjv7su97iTSjJ7DNM4QADeEDBAEdyO1qOMYKmnKEAAL4QEQSYEJMEwiP2CBRv+m6YK0wDkNg3DUJw-TqFcAicC+wqdD0AxEdsax7MssIUZs5G7AshxHBA7Tjnh6AEWAbEEVwlwGvcAyAp8Pz-LCgnAuCUIwhMiIomisKYtiuKEsS5KUhA1K0vSjLMqyTEsRAXHYH2b5XCxrT8fQQGytgsQ-n+1CxIO-bEFywwJOMioJO5lnATZdn-o5OpCmcLn6rc7kQJaXmjPQxpwZwCDStZiVJlBSb0IOUUxWKErxYlvkpWlGVBbgsT9Lg8zUAQEAAO7JtQMz9N5Jy7iAN63t2gCE1p4x6HoAwwzGO1t49rmoD0KKgDHkYAKt7WIAjoqAJDmfoBkGIbhsAkYxvGiYpmmsDAAunA1agSYZlmUCTTNgDRkf6gbBmGEacFGcYJsmqbppwBDUOh3D4eNEBeIAa3KeIATVGADIZy13WtG3PdtqaZtmuZAA)

```typescript
type Length<T extends readonly any[]> = T['length']
```
`ReadonlyArray`は固定長なので、lengthプロパティが定数になる？みたい

## Exclude
組み込みの型ユーティリティExclude <T, U>を使用せず、Uに割り当て可能な型をTから除外する型を実装します。

#### 例
```typescript
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsDMEFoIFEAeBjANgVwCYFNJEETSiAjATwgC0ALfRgOwHMIAKAAQC8HmWAlBADEgXCVAWL4jy2AJaYALghlMR2JjID2TMEWF6IgK5jA8qo6ogEV9A-gyAe+IuA7BkDR6oDOGQD8MgMYZAxQyArhg8ADNFjx8CAAeABUAGggAVQA+H0AkhkB-eUAKV0BtBkAtBkBABh8on0BrBkAnJUAohkBlfUAzBkB75UBfgMArBnt4n1CfQGkGQEiGQBM0wDRNQE0GQGiGesB87UBRiMB1BkA-Bm7AIAZTCEBo+UAJBkAHBkAsf5mfdfkAZyJ5SgAHIIAlfE3sBQgAXggAWUp-HAJggHIAQyeIAB8IJ-J3r6f0E9Iq8njEIMBgN9fp9voCiOsfDMwQBxGTyAAS2HIgHMGQBdHoBYqL6yzo8nke02AC4IVt0HQAHQAK02dI0ACcWMA4MAGS8wCBgDpQBAAPqisXisUQQDKDFK8oBmhmcgEmGeKADCjAKaKIolWuFEH5YF2BxudwwD3wYUisUuEFCEHwqHk+CYuE20QgAH4IEx8AA3fCsiAU62CkCa7XiiCuQCdDIAJhkAjQzOSOhsOi3UCmQAWz2bPkEANQQA3igAI7YF6YSJoA7oHMAXwgADNWRp099OHmELSy5hHSwTsBsPI5Jsnjo8xB0C9NicrQBtIiV-DV4LIEtl4K3e6BZ5vGE-P6woHfN4xYHQ-6AmIn+eoKvyZerzDr40BR4g3dng-Anf-X4ng+X8Jr1ve9S0fDcTS3TZ5FZZQ2C+JhsHTcg-Rhdh2CEC4wW9DQZFwARIgAMTUatNCYP8oJg1gYQQpC-QAsAAF1gyTZMIEAQmtbEjVxAGGGQB1hhYsNUzAUAiDBQBjyMAFW94kAR0VAEhzIkSTJSlqU2WlGWZNkOS5F4mE2AB3P1uV5KBxKkwBoyN6YlSXJKlgBpekmRZdlOVgYBNg0HBBy0bYTIgQBdBlsQA1uVsQAmqMAGQyrKU2z7PUpyOR5PkBSAA)

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

`T`が`U`に割り当て可能なら、値を持たない型である`never`に、割り当て不可能ならその型を返すようにしました。


## Awaited
Promise ライクな型が内包する型を取得する型を実装します。

#### 例
```ts
type ExampleType = Promise<string>

type Result = MyAwaited<ExampleType> // string
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAcCcEC0ECCB3AhgSwC4FMATSZJM8kgIwE8IBZTAY23wCsIBlbAawHsAnTBAAUAAQC2TFqwDOPAZgCUEAMSBcJUBYvqoAO-XuOwz8qygFdsAG1xJsAOzAkVTiICuYwPKqDqAAU9BoxEBLhkAShkB6hkArBkBo9UAZBkBQxUBQZUBNBkBohgjAJIZASwZAOwZACIZAMQZAawZANeVAdP0EwBiGQAcGbMARBkBzBkB1BkBwhlzAaQZAIAZPCEBo+UAJBgrALH+AAx99Q3wAHgBRAA9McW0LfAAVam18AD5BwAsGatzowCEGJMAWDUAIFUBABiy8-PrAMwYIGbmF5dXjVJLyqrqm1o6SQf-cDISLgXvdZvNFis1hAALwQEZ+CYyXD8OwAc3WnRB0IASvgZKYrLD6NQMDgCIQpuCnlCNhBgMAIMjUbY0X9-p11hBAMoMmTcgBkMzKAYUVABhRgGi5QD2DBAANoCbBouyYCwQTD8XDYRiLAC6wgAFrhcNoZAAuBmEfAANwAdLheMBJIw5HxBMBMIQLZhbIwiEhsfjGKjtNZ8NN8PxmEYZEgAI6mfHq3i2JDQJAAFgArNxU8oaDKJFI2E6FDr9YaTQyFbhdaZKFbGPp7QXZPJBMpaglflAuQBxPAACRrtUAXR6AWKjkv1S0bTcBAYxdVbZFaBGjgHB4MBWJgwCBgA5QBAAPpH48n4887n5QDNDIAfhkAkwypEWAU0VD6fXweIDuwH6SWS8ERxksEAhgQtiEDI8K+GMAAyPATJ61DrFyMIkIBwH4KB4EItBsHjHYABmYYQAAqpiUBQAA-MRQHTCBYEQaMRgwdwcG2AhJBkRAlF0KSWB-pSJHsWRxrEYJwm2JaYZ7iAL5vieECAGMMgCdDIAEwyAI0M16KTJslHh+u7YPMAi4BA34AN73LGSoADRgmsjBGQAvhAeG+BAADkoh+kgc5KosrL4sApjqhYMiuQ434ABrElhRjjMy6KYt+ACaUWQTFZl4SwFiEGJpjiJQhH2QloIAFopQxEzRUiKLohAAA+EC2Ll+X8IhX4ldAZWIuMlXdalVUsmidUQJQvC8IsnqIUV0KAXCZlVuhwnCImeGEhlFiLNlIiqmiOV5WGygwly8EHUdrEQPZYWgowmCRsS0okDMtm4FMFkWOM3G-hS4zhes1lxayiGWQ90xPS9phKu9PHkv+iW-RA6WZZtjV7fw52A8DoOTK9kOff+xVw-9g31cjzXo1Aj34HZYMQx9vFfcV0AE9VrJDSNY34BNv0Y5Tz1Y+Db209DlJLHDJNhujWp7oyHlRiGT1IGGej8G10KKwIxKC3x4xiy1UladpECAITWmSKfJgDDDIA6wz67JulgKAJBcoAx5GACreqSAI6KgCQ5uOk7ljOMhzguMhLvwK5rq6tgyOgYYbluXYQC7qSANGRSQTgaU4MrO86Lsuq4IMAMhjYF2CJkCceALoMmSAGtymSAE1R-Kp2W06Z4Hwcrpu267kAA)

```typescript
type MyAwaited<T extends PromiseLike<any>> =
  T extends PromiseLike<infer U>
    ? U extends PromiseLike<any>
      ? MyAwaited<U>
      : U
    : never
```
`T`が`PromiseLike`(Promiseと同じシグネチャで実装された何か)であれば、それに内包された型を`U`とします。
さらに、`U`が`PromiseLike`であれば`MyAwaited`で再帰的に`Promise`に内包された型を取得します。`U`が`PromiseLike`でなければ`U`を返すように実装しました。

最初、`PromiseLike`の部分を`Promise`としていたのですが、以下が通らなくて`PromiseLike`を知りました。
```typescript
type T = { then: (onfulfilled: (arg: number) => any) => any }
type a = MyAwaited<T> // expected number
```

Promiseのシグネチャを独自に実装したもの向けの限定的なインターフェイスらしいです
[Qiitaの記事](https://qiita.com/jamashita/items/7abcd0693dadcef2afb6#asyncawait-%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%97%E3%81%9F%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%9F%E3%81%84-)


## If
条件値`C`、 `C`が truthy である場合の戻り値の型`T`、`C`が falsy である場合の戻り値の型`F`を受け取る`If`を実装します。

#### 例
```typescript
type A = If<true, 'a', 'b'>; // expected to be 'a'
type B = If<false, 'a', 'b'>; // expected to be 'b'
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBBMBsAcEC0ECSAzSyk91gRgJ4QAKAhgG4CmANhAOI0CuAzgBYDWA9hRABQABAA5l2TAC4cAlBADEgXCVAWL5yJASxoswWWToiArmMDyqlqiBDc0BvcoBIFAAYBhK4EAGCLauAZBgjiAThLbFA5gyAhBkBohkAWDUAIFUA7BkBuI0AohgtwwGj1KwAVB2c3dDINPyCwqNiEqwAxK0AkhkB15UBFBkA15UCrDFLAfO1AUYjAdQZAPwZATQZAIAYsc2s7CEB7BitPJiorQGkGKwyNcfDASwZAQwZASIYJgMDAZQZACwYXQHxzQFD9QFUGQBiGTpd7ZKsILadiocBvuUB4QwSSrc2d30BZBk6erEBo+UAEgyABwZAFj-xicVhGmig4kIQioEAAghAALxodAAHlGVAANBAAORkfF4-H4fEAPgA3BBgMAIFQAB7wgDG4ioABN3FwIPgEYT8VhYfCIAAhVHojEzFi4glEklkqk0umMllsznibm8glkrCQqzg8kMVTiAASTHwvkAXR6AWKiOoEQWxxOIhCwAFy08QsZlsAB0ACsWD6uB4AObAODwYB+shgEDALSgCAAfRTqbTqYgGw2gGsGQDNDIAfhkAkwwlQAYUYBTRWT6arSYgcbAQoRGAxNnpDLZADt2SweVwuDQqGR23iknjCoa0S3GR2u+4vAiAPwQJIQV0QQoJkCV6tpiCAMYZAJ0MgAmGQCNDPn91vtyna-HVABbITB8TuOEIgDeEAAogBHJiZPEfpkqFZCAAF8IHQDwuFvAkBAbJBvUyft2xDKgWGANQNAFesXwgZlRFQ8UAG0sAA1UMW-X8aAxJtsRJOVtQpOiKXJHESMA1lyJ-TJqMxKUZX5PFoBYmByRYsAAF0EzpWCWCQFUgPEOSPEgjxsOFKhlODcUm3bJgaBoJj5QpDcL0vCBAEJrcJ913QBhhkAdYZTO3a8wFALBDUAY8jABVvEpAEdFQBIcztB0nRdd1gE9b1-UDYMwwjYBBxYAB3DSoxjKAPO8wBoyPtR1nTdD0vV9AMg1DcMEGAFg+zULh22hCBDUAXQZwkANblwkAJqjABkMoLctC8LCqikro1jeMgA)

```typescript
type If<C extends boolean, T, F> = C extends true ? T : F
```
`C`が`boolean`で、`true`なら`T`、`true`でないなら`F`が返るように実装しました。


## Concat
JavaScript の`Array.concat`関数を型システムに実装します。この型は 2 つの引数を受け取り、受け取ったイテレータの要素を順に含む新しい配列を返します。

#### 例
```typescript
type Result = Concat<[1], [2]>; // expected to be [1, 2]
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=20&ssc=71&pln=20&pc=1#code/PQKgUABBCsDMsQLQQMIHsB2BjAhgF0iUWJMICMBPCAQQwBMAnAUyoGkGcBnNAN04GsqACgACZZrAAM-DgDYAnFk4BKCAGJAuEqAsX3U4GHCmEJqTEQFcxgeVUjUAFI4eOAMpYGASwAOeCIDsGAAbV9HAoAOixMXDxfQCLUwAdTQCSGQGj1QHaGQE6GQDGGQAOGQGsGQHztQFGIwHUGQD8GQE0GQCAGQGUGbwTAewYIACYIQBMGb0BUfXjAdeVARQZANeVAKIZAQAZunsBjBkB9BkAShjTAG4ZAH4ZAfoZvQEDIwAJfOMAwDKzAahVAAIZABtMCwBEGQFlEwHQlOMAV+OLy6whAaPlACQZABwZALH-b3w+8TkI8CncmCAAJSYnAArgAbLwAXlQ4XwAB4ANoARgAugAaCCI+qogB8AG4IMBgBAmAAPf5YPBMOgQPBoCBkAEozE4wgfXy3XEQADirjwAAlQWRAOYMgC6PQCxUSVANEMLwAFng8O5OAAuYlfLBy4IAK04wTQDAA5sA4LBgNqcGAQMAjKAIAB9R1O51OiAVCpZQDNDLNAJMMcUAGFGAU0UHS7Q-aINawL9-rDsAiACqksnU+icGiBCjwnAYCi4zEAVSTKboaYCBizOdx3JhiOCdfjmLrwXzqNtIBDYedEDSKUAEwyARoZZikO53HRGba4ALbuA1eaMAgDeEAAogBHUE4cGY5cUphUiAAXwgADMGGhJxAAOQieeITWb8FMDCGkHAUF4VzgziXozziC4TgQQgGtCB3Sk8HhNcN3BeF0DjCDEQxLE8UxRCq3RUDdypSD103WC4QQpCURQrE0XQzDwJw6D8PgpFkVZIjYExAAWEiWQaTEmIgVjyKgMC9wgqC8LgiIkUvZFL1ZTFL1gS8iOPTdAMxMg0DQR9s2k5i5LzLFxMkjir1kzEFK-JhlNU9SME07S8zAVswDtUcu0AQmtvHSQBhhkAdYYR1HccHPAKBuUAY8jABVvOJAEdFQBIcxleVFWVNVgA1LVdX1I0TXgYBs04AB3JgGHNS1AogUK4kAaMjZQVJVVXVThNR1PUDWNU1gG4cF31cTBviKwBdBm8QA1uW8QAmqMAGQzYqqhKkvq1LjQtK0bSAA)

```typescript
type Concat<T extends Array<any>, U extends Array<any>> = [...T, ...U]
```
配列`T`と`U`をスプレッド構文で結合しました


## Includes
納得いかないから今度書きます
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAcCc0QLQQJIDsDGAbArgEwFMBnSJRci0gIwE8I0cssIAKAAQGsa0CAzHDgEoIAYkC4SoCxfUQEMATrOk0wpEaoiArmMDyqsqgApaQDdpAZQyyAlgAcALoDsGAAYBBeYoB05zLkL3ARamAHU0AkhkBo9UB2hkBOhkAxhkADhkBrBkB87UBRiMB1BkA-BkBNBkAgBkBlBlsgwHsGQEAGACYIQBMGW0BUfUDAdeVARQZANeVAKIYC+2tZHAJ7QBCGe15pLCJOgMAvxUBspSTAKwZawBiGQAcGCcaUwG0GQGSGDJ0IQGj5QAkGWcAsf437I+sSKGsaSwIIcyIABXMmOQBZAjQIAF5UT3xiAB4AbQA5ABpOREQEAGgggIAokRzHgbuZIdCAOrSAC2OBwKMBxmkaGsBOkgIAulDAQARcwAe0BAD4IMBgBACAAPS4YawEPAQaw0iBUK69fqDeykI7i0iMgDi5msAAkcFRAOYMgC6PQCxUWlANEMewAFtZrJYiAAuZknDB61wAKyIrhpsgA5sA4NBgNbpGAQMBlKAIAB9QNB4NBiBZLIxQDNDIAfhkAkwwBQAYUYBTRQDIbT-og3rA50uX2wPyIvwAKqy2dy0HgiBBZARpHgaWgsHQCTR-uSIABVRmfEvs8uViD-Dy8AiyCAAMXMsiI1ihrnnw9HEAASsRrKTSAB+CBPGgwgCOOH6v0n09nncZfdeA7aHVIUG3t4I94gJrzXj+q5nUK7pDffQGZ9swuK5dwPI8sF+AANKEAE1u1YYt6RYYR3kZXsy2vKsoIgbcAEZXwgIphCvCsqxYJCUI+dDS37KtYNwiACLfYitz5dpnygf9RSAv10zTCAIjCQAJhkARoZozCVN+NDLNzAxSwHWsPkQIgABvCBwP6KEYQ5AguQgABfCBeFkGkMWhNgcwIRBLX6LBXkdYhgBwawHnBZQrIgDBpEGKtPn+UgdM5axfk0yD0HzQhCyBUFp1xOEESRXF0SxHEKXxQliTJClYvBekoSfel8sC3SuVCw9jwij9opBMF4vhRF4WSzFsVxDKiTQEl2ypWkGShADBiKiESuC8qIN+KqCwBPCoSKKEAGYoQAVihAA2KEAHZ2w2-L2I6IaRr0kKwom74oum2aFuWtbNvbAAWXaBoIA6oCCo6xsqs6-n+GaiIW9sil2write0rjoq8Kvui365ogeb2zwoGOJejSwY+yHIu+1SDPbdTpDfQFHEBQzHp4lG3rKk7JvO-4qBpGl7IJS64euiB1ogLb+rJrnAPJtGqahgEn2ZxaIBWtnbqhOmGdrNBSd5kHUdGgXMeip6RdZ9nOeM7m9uexWKfB8bqaxiB8ehInDNx6ta3rRtmwJy2DPlwaDf5iHTtVgF1JrOsGybM3HeJnGoTxoOSZ513htB5WPZN6GEYgAAfIiXf16OlfelXqum5OiIRtO+dj43Bf+BgmHbHAKz4DweULt3i8+r3-irwheFrvB23LrB6+GjcwD46TQ0AQmtbEiQBhhkAdYYpKHzMfVAaUIEAY8jABVvAJAEdFQBIcx1fVDWNM1gAtK1bXtJ0XXgYACSIAB3Ud3U9KBGVXgJAGjI3UDSNU1zSIS0bTtB1nSumAEQBmLlaRoFOBARkgBdBlsIANblbCACaowAMhm70-gfI+f9T7Og9F6H0QA)


## Push
`Array.push`のジェネリックバージョンを実装します。

#### 例
```typescript
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

#### 実装
```typescript
type Push<T extends Array<any>, U> = [...T, U]
```
`T`をスプレッド構文で展開して、`U`をその配列の最後に付け足しました


## Unshift
`Array.unshift`の型バージョンを実装します。
```typescript
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
```

#### 実装
```typescript
type Unshift<T extends Array<any>, U> = [U, ...T]
```
`T`をスプレッド構文で展開して、`U`をその配列の最初に付け足しました


## Parameters
組み込みの型ユーティリティ`Parameters<T>`を使用せず、`T`からタプル型を構築する型を実装します。

#### 例
```typescript
const foo = (arg1: string, arg2: number): void => {}
type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=22&ssc=103&pln=22&pc=1#code/PQKgUABBDM0IwCYIFoIAUCGAnDBbApgC75YDOkKyV1FARgJ4S4CWAJgPZbMBe+LEACgACLDl14sAlBADEgXCVAWL6zmAOwBmJWYQCuABwA2+WbW3N9hZKrAUZtiICuYwPKq1qIBFfQP4MgHvj3gOwZA0eqAZwyAPwyAYwyAxQyAVwzhAAaYOATEZAA8ACoAfNGASQyA-vKAFK6A2gyAWgyAgAzRKdGA0gyAkQyA-QyA6wyA1wx+mYDTloCT3oCaDIDRDM2A+dqAoxGA6gyAfgwdgEAMLhCA0fKAEgyADgyAWP+T0SuE5FAAxuwqpIQQauzsEAC8gtgA5nAAXBC7XCrnADQQFwg3Ktq4tCSSNwBu7DYJzSEAA3gBfSaEei6IwAMW0Kg2hGY2zieFIKRhRlOAFl6OiEiRSElobD2Gp9ocQcBgBAANoXa63Qj3J4vLDnN4QD5fEgAXQoK2ikxBAHFmIQABLaWiAcwZAF0egFio7oLAAWhEIulIV1paw2aoAdAArUiGzjnYCwRDAY0YMAgYDWUAQAD67o9no9EEAygw+wDWDIBmhiCgEmGTKADCjAKaKbq9sddEEdYDJRnxhKIxNSEHwAA9iCpWKRBIbixcdS8VPR6fzpMcQRgKyDTiks7n8PnCwJi4bSzdVBosBAAKo1usViAAfiHEHe+D+JGdIBjcc9EBCgE6GQATDIBGhiCa6Xy-dCadzFwuk4e2TYIgAFEAI7aDD6Z7X7Ow5EQcH7LDsXAQADkQjJsgBqPoYDz4KQwDaCi+ikH+1hbDsewHEcpwCEyNx3Ko7KvO8nzfFgvwQACQK1mCkKIbsEC0NgJxnJyzK0Ichj1s8uFXhgNx-gAgn+H5ESRrDAuRYCUXsNHcHRAgCYCQlkRC1iXhsGCkBBdH0hQL5voQSR3g++hJKm2B4OmyTJhSVLsGkzz0lhDzPLyBH8mk1maa++DIrp96PoZBLGUSZnYhZNFYNZDJMewLEqM8oIvFxvEfs5rlQFpHk6XpPlGfEpkkuZlISWFVYuY8YCCmALoHiugCE1j4a4hIAwwx1PuB5HuV4BQCCgDHkYAKt6ZIAjoqAJDmqoalqOp6qQBommaFpWvACDAPWpAAO4kLa9odRAPWZIA0ZFdOqmrarqwD6kaprmpys02qQkXQaiOwUCCgC6DD4gBrcj4gBNUYAMhn7aNR0nVN52WnaDpOkAA)
```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer U) => any ? U : never
```
引数の型を`U`として、この型関数に`T`が一致するなら`U`が返る型を作りました


## Get Return Type
組み込みの型ユーティリティ`ReturnType<T>`を使用せず、`T`の戻り値の型を取得する型を実装します。
#### 例
```typescript
const fn = (v: boolean) => {
  if (v)
    return 1
  else
    return 2
}

type a = MyReturnType<typeof fn> // should be "1 | 2"
```

#### 実装
```typescript
type MyReturnType<T> = T extends (...arg: any) => infer U ? U : never
```
返り値の型を`U`とする型関数に、`T`が一致する場合は`U`を返す型を実装しました


## Omit
組み込みの型ユーティリティ`Omit<T, K>`を使用せず、`T`のプロパティから`K`を削除する型を実装します。

#### 例
```typescript
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```
#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=32&ssc=2&pln=30&pc=1#code/PQKgUABBDMELQQPIFsCWAXS8491gRgJ4QCCAdugBYD2ZxAYgK4QAUAAgIYUBmjAlBADEgWjlAWL5DGZVLSH5GqADbo4qMmCyDNEQFcxgeVV1UQCK+gfwZAPfHHAdgyBo9UBnDIB+GQGMMgYoZAVwzOABigwAeACoAaCABpAD53QCSGQH95QApXQG0GQC0GQEAGd193C0B1hkBbhkBFhmdAaQZASIZ3IIjAKSVAEzTATQZAaIYrcMB87UBRiMB1BkA-BkrAIAYDCEBo+UAJBkAHBm73EfQAZyxVdABTACduDgBjaYhfagATaggAbywodAwFaYAuCDH0WdUAcz2IdemxxcuABwPaU-PLshuoKEXqZDPI4zdanfDUahHLhYAC+3XQhGeKzWmwACrNpgA3VDTADuEAAvBAALKELzoPwbaiBADk90eLzeZBpEAAPhAaQd0EcaSFuv8yOcIOgqacUdR0VicfiibtfhB-oDgdNQRAFgoxtN-LCsCN3N0QhAAOIYAASjHwgHMGQBdHoBYqJqgCx-yjodDPMbHYDAcaLSgAOgAVmNfdRZldgNBgP6OGAQMB1KAIAB9ZMp1MpiCAZQYM4BrBkAzQx2QCTDOFABhRgFNFJNpyuJiCxsAIpEksloCkBYIQaYADxmZHWYwgAGtpoRqNxVobZVgANoAVQgqggAFEO4sFIx7t5B8PR63QgBdMUz3dgOFgBNVysQByAToZABMMgEaGOxXivn9O11CAkPoYWIlbbRcAR0YDgFECJckUWL8YTVWYAQ5Nh62mOAfWAo5vgeYBGAODUaXUBCFQ4TU+yJScsDA6YIO8BdAOAyiO3AkEAEZAlJclKU2Wl6SeVBXmkZkQn47UoDIiiqKAhRaPolUACZmKbHxxQ4h4uJ42gWXZGlFSBaYQV5ASwCPU9gAgeCxjgTt6LM2YYNmOsf3bKyQ0JRtWIUjlOMZXi1I5VRMWA1B1l5dQpjmBZllWKkdiwLkjg+C5riwdzuKZWKvh+BUAS0kEwQhKE1BPYL5iWFZhMYyL9kOE4zji74sE05VVXBSFpmhfKKBCorFzo8iQSksrhQqlL4pPM8X3TQBCawsK8HEAYYZ0mfUaazjUAsENQBjyMAFW9wkAR0VAEhzR1nVdd1PW9P1A2DUNw2ALgxlxOZI2jKA1s2wBoyOqJ0XTdD0vUeU6gxDMMIzGSFMN4iZHogQBdBgsQA1uQsQAmqMAGQz3sOr6ToDP6LqjGM4yAA)
```typescript
type MyOmit<T, K extends keyof T> = {
  [U in Exclude<keyof T, K>]: T[U]
}
```
`Exclude<keyof T, K>`で`T`のプロパティから`K`を除いたユニオン型を作ります。それを`in`で`U`に展開して、`K`を除いた型を作りました


## Readonly 2
2つの型引数TとKを取る`MyReadonly2<T, K>`を実装します。

`K`が指定されている場合は、`T`の中の`K`のプロパティのみを読み取り専用にします。`K`が指定されていない場合は、通常の`Readonly<T>`と同様に、すべてのプロパティを読み取り専用にします。

#### 例
```typescript
interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: "Hey",
  description: "foobar",
  completed: false,
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
todo.completed = true // OK
```

#### 実装
```typescript
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [U in K]: T[U]
} & {
  [U in Exclude<keyof T, K>]: T[U]
}
```
`K`で渡されたプロパティを`readonly`にして、`T`のプロパティから`K`のプロパティを除いた型をそのまま追加するようにしました

デフォルト型引数初めて知りました

#### [デフォルト型引数](https://typescriptbook.jp/reference/generics/default-type-parameter)
型引数にデフォルトの型を指定することができる。型引数がなかったときはジェネリクス型`T`が`Error`になる

```typescript
type MyErrorEvent<T = Error> = {
  error: T;
  type: string;
};
```

型引数の制約と併用することもできる
```typescript
type MyErrorEvent<T extends Error = SyntaxError> = {
  error: T;
  type: string;
};
```
型を制約した場合は、デフォルトの型引数もその制約を満たす必要がある


## DeepReadonly
オブジェクトの全てのパラメータと、そのサブオブジェクトを再帰的に読み取り専用にする

#### 使い方例
```typescript
type X = {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

type Expected = {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCcELQQCIFNkAcICVkEMAmA9gHYA2AnpPHNTZQEZkQCCRALgBbGMBiArhAAoAAjjYAzXgEoIAYkC0coCxfWQCdchUoxkE6AK2QBjVnADWyMgGdZeVGjCUZDiICuYwPKqdqICqGQGsMgDoZA5QyA9QyAEwyAdgyAmgyAngyAZgwhgIsMgJcMgIcMgD8MgP0MyYAQ-4BSDIARDIDODIC6DCGArQxe3v7BgEkMgLGKgAx6gCFugNYMgJD-lYC1UYD+DIBryoBRDIBAOoAUro1hgNEMAAYo6Nj4xOQAPAAqAHxjlYD52oCjEYDqDIB+DGGAQAzuEIDKDCGATVGAMhmA5gyA9gzlgaEdlYCORoDGDFGAIgwjgBYMgM8GgFnaWyigHkGQAGDIBVBg++0AsomAdCVAIAMgCLUwAOpvCAvFAJ0MgCsGQCWDDdAMABgDtDUaAUf1AIGRN0AQgw9HaAbQZAMkM+y2gGkGLbwwD3yoBfgKxgAU0nqADctAKAMWMAjQzJDGVQDVDIAFhmSo2O3yu8MAV4GAMCVlYBquMagERjQBkRvLvoAZBiugFkGPaHSiAaPlABIMgAcGI5jR2scyUVhkNDICAADQgAF4IABvShQAAeAC5A8GoBAcBGAIxRqB0CMAcnYAEsU1GAL5Rsip9hmLNQXOu92egCiIY9hmQeD9kejEFUMw0EHDjabzbUs0YsYgCa73db5AgyYgaczOajLfUo-zE8LZGLEFLUDdHogCwIhAbkzQ0znZDmXqWEGAwAg5k4vBI9bonvMOAAtp6cJYxlWa6w62NKI6-0oM8AHF01YAAJXg6CuQAuj0AWKjRkALH-2FYVg0HMMML2dfR2AAOh0cxcIIZQAHNgGgYAdBwMAQGAOxQAgAB9ZiWNYliTmORpAGaGZJAEmGSpAAwowBTRSYtixMYiBaLsDdPX3Q9e0WM9-SDKBZ17CAAG0AAUIHTIgIFMMgCDELcAF0IwWbTTIgZAQx-Ig8EsPgiEMdNiAgAB+LcrIgCM5J7DRFispYwFLBjxLEiBADGGDEgjFDFRIi9ipPTZ80GI1gIBkwMIArABHXgcBIAAaXLqwMTLswgMRlAIZ8JyEGS4BwoqSGQIgSOQcxgF4Vh0xIcwszAbL9HfLqGw0ygvwquZ8sKkg5n8kdjy9OMllK6bazwNb1qm8rDFmgqisWmx5MCr0ACZ1rK786yu3bTOk8tvTjBsVJjCMBGkX0zwui76AjcxWGUPSSMofQI3eqA8AjOgCAINrRCjZBIcTCASNRocoHYTGsagdMI2B3hkDRpsdFTIGQY6lch1zPHjALZASBIAgaejOmuxICNJrxycU2K0nOzx59ubTItHrx7MBaHCX2coXNS2yy63o+q9gdB1cIAAHxy8ciF4Z8H2UVcns3Taf22t7KDUtt+y+v1fv+1SAtHcdKdB62XcYCGheHI8IBhsd4cRogZy9mzcabG3Rwx32o-DnG467aPGAJrLlGJwXneWiByYnd3qcFjmhxTgzGeZ1m0eL6NS65v31J5rG+elrGoax0uRfrtsNLF5dZdplum37k2S1C03K32i2LpV0v+wLkjNZ1gMu9diN9cN5BjbCkBEqSiTAEJrEIMSiwBhhkAdYZd6SyS6NAICIEAY8jABVvSpAEdFQBIcyQlC0IwrDzBw-DCLETIhRUQ5gADum9KLUSgGeJ+lRADRkSMZCqF0KYWANhPCBEiKkXIsAcwCNepuSIC6GBEAiiADW5c4FxkHfzQRggB2CyJURonRIAA)
```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : DeepReadonly<T[P]>
}
```
以前作った、`Readonly`を拡張して、`T[P]`が関数の時はそのまま、違った場合は再帰的に`T[P]`を`DeepReadonly`します

`T`が`string`の時、`string`になるのなんで🤔
```typescript
type DeepReadonly<T extends object> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : T[P] extends object ? DeepReadonly<T[P]> : T[P]
}
```
最初こうしてた


## TupleToUnion
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAMEFoIBUCuAHANgUwgFwHsIBVAOwEsDTJEE76aAjATwgEFS8ALK1gMVQQAFAAEAhpwBmqAJQQAxIFo5QFi+C8qUnYATgrwYcC1BSpga88xEBXMYHlVU1ED9DIHWGQNcMgOwZAJAqBpBkCRDIDOGQNMMgFUMgM8MgNHqgEkMgPiugAhGgJoMgNEMAAZoWNjIBGSUpAA8yAB8ieGA+dqAoxGA6gyAfgyxgEAMdhCA0fKAEgyADgx1ie14AM40eMzouGxaOgC8EADaAOTQEwA0EBMATLPzAMwTALp1vf0o2J14EKMpOOmZVNmDWnkQwMAQ2AAe-QDGeNgAJvhEjLhTExAAH3mS0BqwmNHaiTq1wA4uQ8AAJVCMQDmDIAuj0AsVEJQBY-1w8Hh0J0AFy3LrPLgAOgAVp0KQQtABzYBwYBUsRgEDAUygCAAfX5AsFAoggGUGEWAawZAM0MgB+GQCTDOFABhRgFNFPlCtW8iCc0zbXDHNIZYw5fKHFD3B5vUjvTrsIZiZjZdSaHTEa4AfhIECJEFI2AAbtpuSBVerBRBAGMMgE6GQATDIBGhmlEeDIf5mq55AAtuh6QcdRAAN4QACiAEdUGJMHMC09sK8IABfCCSLQENPzEQ6hDkss4UgMvbAVB4ciYTrgsA555iTp7E1jGiVl54bLF0uYXL6fVnHJjaALFZzCYAFgArAA2ZZ4LSobDrPJzHcrUGH0--IEXq95W9zquvJclstr1JTkNbJt13G8713D8ZjATYwB5JNQ0AQmtXAjMNAGGGRxEyTFM4PAKBrkAY8jABVvcJAEdFQBIcxxPECWJUlOnJalaXpJkWQkToAHdtFZdl8IgYjwkAaMj4lxfFCRJYAyUpGk6UZZlYGAToCEwAcsm6XjAF0GVxADW5VxACaowAZDJEmjxMkxiZKZNkOS5IA)

## Chainable Options
JavaScript では、チェイン可能なオプションがよく使われます。しかし、TypeScript に切り替えたとき、正しく型を付けることができますか？

この課題では、オブジェクトでもクラスでも何でもいいので、 `option(key, value)` と `get()` の 2 つの関数を提供する型を定義してください。`option` では、与えられたキーと値を使って現在の config の型を拡張できます。最終的な結果は `get` で取得することにしましょう。


#### 例
```typescript
declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// expect the type of result to be:
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=45&ssc=2&pln=42&pc=1#code/PQKgUABBCMBMEFoIGEAWBDAlgO3QIwBsBTCAeQAcAXTAe2wGdJEEXWm8BPCAQW0tTpcAYgFcIACgAC6PgDMRASggBiQLRygLF8V6cuQKYAxump0wTZeYiArmMDyqqagApdADd0AZX0AnTFQiBzBkD2DICADICDDIDlDIAlDIDPDID3yoC-AYBWDIBVDIDrDIDtDIDnDJGAMgyAEQyA8gyA-vKA8QyAMQyAfgyAmgyAQAyA6gyA0gw1gQAqHORE7l4+gNYMgOBKgFEMgP9mgBIMgPoMgBYMgLIMgYDG1jV5gNHqgEkMgBtygIoMgNEMgMoMY1m+E5V1gPj-dhCbgHYMgE1RgDIZAYGJgGsMgB0MoYD1DIATDL6AQQwvgJcMgJ0MX0AqvJfQAiDCCzr5AhAAAY0Ki0bDiADWRA4ABoIC4CCIiApoRAxjCAOZESjiPEQM4QeCAEwYzoAi1MADqaLQALxoBs+Qq6yWgCztQCV-jVAGYMeUABgyAVQYQVVYfC6PjboA4OSGgEiGEojQC1DIAfhjGgBIFRYFQDGDALAH-OgAp1Kn6OiyTBEylLQCHRoBWfT2lSqgABzQBCvoAQt3igAVfQA55v5iaTZYA15UA6fqc7ZdGplGqAcIZAGIMVROgGj5IaABwYTtCs5RGFAACZEfQEdAeEjmhiUCDly1EgBcKAwOHwxBO5foldL9BEBErAF4qxarUwoAA6OHGREAclkNBok4xcAAzAphxAx9Kp7gALZEecQSeUVpEBD6DAEYjYEn0ScrqCj8cI8STvAlvcAb0x6GxRHrk4AEkQ540BAADqNAeAQeaThAAC+t53iOJJkiuTDAMAEBEAAHm0+iVvwJCHm0EA0LIECdt2eHAXgP5MDglBEB4sjoPoJAAEpEF2PYQG+q4zjQ9bYCIW7UR4q7bj+EDtl4l6ri+Hj1jxd53liOL1lJOBEquMFMNpUBZtCJznNYVyLIAx5F5CMgCBDF0EAAFb0MAOaUoAtwyPIAwwwvIsgAfZnkgCj+oAgZH+IAQgx9GUgDaDIAyQxVPMgA3DIAmwyANcMZyuR5wqrN5IJCmKEqZiiHD4gG0LqZe+JnIA-gyLIA68qrGsgTQipRAFYA33KAPCGZxLNVazrGMgB3ctygqfIA05YguFUWADAqgAaDDCeX4lk1IQIAe2qAIR2oolFsYzBaFkVJkwAB8EAAOKYJQf4iHgviAF0egCxUZygBY-6glCUOQ9C1mhOaniO9ljh4RLAHAwC2egYAgMApigBAAD6UPQzD0OnJsXSAM0M6qAJMMiyABhRgCmipDsO4xDEAg6YhEkGgWC4IQRAADy8PQED9m+MH7fTTAPnQECUwA0hhmH0dgea08VRIYgAatzvP8xAMgcLtyKovWHMYg19bCwo9ak02FOU6QW7HdTDAYhz+0AGTcRAADaeUQDgEAcwAusrsG7UwSHkvWNNgNpYDg3juMQIAYwx-G8gCNDOqfw4z7cOE5gW7kOBeFHqb3B6CiGIAKLYYWlYwRAsgeDQW77pIxMnmeF5XsAIjUAQ16mAWRYlmWdDtpLauNuTLZgG2HYcRR0B05LTDrhOT58XuS7wUPj7Pq+GIfkr+4AUBoHgZB0FwYPrObugO57geR4l1+ZccTeg8uyhXdkT3PbwP2QP3huT7ibvMg0PhHgQE-8FoRARf0AgWE4UoP-DwedRL32HpOJ+GJJzFmbp-U+pJySmAvuRHsi5+53zXJvR+29dzQJfm-D+uCT5QG-r-f+GdcLANARvB+kDiELlgMuBByEiYJ0MPQDi-czZMHToA6mycqbExIpfTilBoBp0ofRPM0Bdq7TRLwqRAjMAokpsI0iqDKCwEkYAogeZYByIUVAPhmdlGqPUaIiii4dGZz0YuQxYBbZsKIiY3Cei+7MygHxASQkRLsBLApVc89BY6SYOJNSlBpKaU9sTCArjpE324mE3BESoke2cSQeJdj+6KSITuHxwkGLpK9iAcOEd8aAEJrM4fw-ZuWSGUiOBNQagD2hAUygAVb0WIAR0VACQ5ndB6T0XpvXoB9L64Ffr-RkPQAA7gxAGmD9odMWIAaMj1j3Ues9V6jkRmoE+vQb6EzYDAHoDQbEE5cwQH2oAXQYziADW5S4Vx1mDK2e9XZYyfrzOBqDIAA)

```typescript
type Chainable<Ans = {}> = {
  option <K extends string, V extends any>(key: K, value: V): Chainable<Omit<Ans, K> & { [key in K]: V }>
  get(): Ans
}
```

`Chainable` にデフォルト型引数 `Ans = {}`を指定して、最初に空のオブジェクトの型を持たせます。

option関数の返り値の型は、`Ans`から`K`を除外して、`{ K: V }`とペアにしたものを`Chainable`の引数に渡したものとしました。

`get`関数の返り値の型を`Ans`にすれば完成です。

#### [Record](https://typescriptbook.jp/reference/type-reuse/utility-types/record)
`Record<Keys, Type>`はプロパティのキーが`Keys`であり、プロパティの値が`Type`であるオブジェクト型を作るユーティリティ型です。

解答例を見ている時に使っている例があって知りました。`Ans`の型を`string`のキーと何かのペアとして制約をかけれます。
```typescript
type Chainable<Ans extends Record<string, unknown> = {}> ...略
```


## Last
配列 `T` を受け取り、その最後の要素の型を返す汎用的な `Last<T>` を実装してください。

#### 例
```typescript
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type tail1 = Last<arr1> // expected to be 'c'
type tail2 = Last<arr2> // expected to be 1
```

#### 実装
```typescript
type Last<T extends any[]> = T extends [...any, infer U] ? U : never
```
スプレッド演算で、配列の最後の要素を`U`として、それを返す型を作りました。


## Pop
配列 `T` を受け取り、最後の要素を除いた配列を返す汎用的な `Pop<T>` を実装してください。

#### 例
```typescript
type arr1 = ['a', 'b', 'c', 'd']
type arr2 = [3, 2, 1]

type re1 = Pop<arr1> // expected to be ['a', 'b', 'c']
type re2 = Pop<arr2> // expected to be [3, 2]
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ts=4.9.4&ssl=28&ssc=65&pln=28&pc=1#code/PQKgUABBCMBsEFoIAUD2AHSiE91gRgJ4QCCAdgC4AWqZxAYgK4QAUAAgIaUBmjAlBADEgWjlAWL5COAJ0kdCYLIMURAVzGB5VXlQAfBEDKDIDsGQE1RgGQzA5gyB7BgAqhdAFMAygGNJAS3QUIAFgB0ABkAyDIAVxoAWmoCqDIAxDIB+DICaDBoQgLKJgOhKEAAGFskQgEkMgOvKgIoMgGvKgFEMgIAMgADmgDH6eoCBkYAEvhmAJmmAIgyA+gyJGYAr8VGAcjaAFK6AIW6AVgwpaOgAPBaa6RmA+dqAoxGA6gyAZgyA8gyABgwhDYBADLGA0fKAEgyADgyxyccUAM5YFNY2EFKS0BAAvBAA2gDkHK8ANBCv+F8-Dn+rwAJq8ALoXK43aQAJkeLwAzN8Yd9oBDIbYIJIbPcnsMRrdoNpgMAIDYAB62BwUGzAiAUVAQfDXN4fb6-IGAiFQS6Y7FwvEYAmw4mkilUml0hlMllIiAw7kpY6xEAgQBSDBEcqqAFwQQAwKoANy0A1gwpOxUZzcCjJIpDRinKjWlIAVTI9otVoggCCGWYmQCyDNFANIMgHx-2LaADizgoAAlGPgTIAuj0AsVFRQDRDIAsf6oFAo6FO2pJZwcVC8ACtTl5UJIAObAODAYscMAgYDyUAQAD6Hc7Xc7uh0RsAzQyAH4ZAJMMGUAGFGAU0V292Z22IE2wLzrviLGTyTSyMDTjc6M8wdonquKRuty8vOfnGRuDZJChvlxCGCIAB+FAQXV7lsgaezrsQQBjDIAnQyABMMgCNDIOgE-r+Hbzs2zgALboBW7hLhAADeEAAKIAI6MBwAA23yYZSNjUhAAC+EDcJIqDwT8bBLgghYEfhNhkJWNinMAjAUM4+GnK88ioQ4HCnJx8LPFgxESiMOF4fhIz4s8coojA+7fMpyL7ponxSSR1KybhBGKUKrJAn87KAuyoLqS87zmZy4KaDpekyXJxlKbZe7Obp6KttBf6AITWeiAf+gDDDIA6wxQdBsFgKAWDaIAx5GACreGSAI6KgCQ5qmGZZjmebAAWRaluWVY1rAwBcKcADuN51g2WgQClGSANGR6aZtmub5qchYlmWFbVrWpyoPhPHOLQ5wNYAugx6IAa3KGEYOUdflhW9SV1b1o2zZAA)

```typescript
type Pop<T extends any[]> = T extends [...infer P, any] ? P : []
```
スプレッド演算子と`infer`を組み合わせました。タプルの最後以外の要素を`P`として、それを返す型を作りました。


## PromiseAll
Promise ライクなオブジェクトの配列を受け取る関数 `PromiseAll` に型を付けてください。戻り値は `Promise<T>` である必要があります。ここで、`T` は解決された結果の配列です。

#### 例
```typescript
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

// expected to be `Promise<[number, 42, string]>`
const p = PromiseAll([promise1, promise2, promise3] as const)
```

#### 実装
```typescript
declare function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
  [K in keyof T]: Awaited<T[K]>
}>
```

#### [Mapped Tuple Type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#mapped-types-on-tuples-and-arrays)

`Mapped Type`のマッピング挙動が、`Array`か`Tuple`を渡したときに変わる
[プルリク](https://github.com/Microsoft/TypeScript/pull/26063)

`Mapped Type`書く時に`{}`で囲っているの、オブジェクトだからだと思ってたけど、拡張されてたらしい


## LookUp
Union 型から特定の型を属性を使って取得したいことがあります。

この課題では、`Cat | Dog` という Union 型に共通する `type` というフィールドを使って、対応する型を取得します。

#### 例
```typescript
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBBsBMEFoIBUCeAHAphAMgezwGsBXdSRBSq8gI1QgEEA7AFwAs8n6AxYiACgACAQ1YAzYgEoIAYkC0coCxfWcSYBLTrIC2wsuRn6IgK5jA8qphyAVTUbA0eqBpBkCRDIE8nQFnagOwZrgJIZAejqByAw+B-eUBjBkAzBkA15UB0-UB1BkB9BkARBkBlBkALBkAZBkAhBkAohkA-BkBNBkAgBjMoeNdAJqjAGQzAcwZAewZAQAYAAwBhYRYIAB8IABE8AHNaiETYwDEGCEt1JghrQGsGQEdFQCwE7MBohghalgxMXv6BwFWGQGKGQB+GQGuGQEmGAJDqwD-tQB39Bc8IyJzcwBMGTPTqwFO5QGg5V0Bo+VdACIYBibVJb4IjmdAAHk6XVaEEaLAANBAAOQAE26SIAfL1XIAWDUAECqVJZQ3oeOogwhgyHdGFwxFIgDGTUx2PxhIaTRJEQWSQmgCsGLJ5ApLWrLADO5FUrEwACcxMJ6dg4RAAN7kKArLAALmRjJYSLVEBo0swmBRou1SIYdFFoslqlESJhSIAyhxpexhKppY62kj6sRpQAbH3IgBCmCYXWEwfIAF8hZKWDK5QqOtTVVB1asLWiuvrM4bjabzciABJ4FQokNI0PS1QsFiiVDV0PEQOB3MtvAADxl+cz9Lwgbw0otRrwAHcmNWJ2x65hqzRA-LCP34+QNdgALKoKEQAC8uAIFIhSraULpnYxEGAwAgmG7WHpSZREBYeEN2FqxPIItqQuvABxetS2IGhykALo9AFiohZACx-tgG3Qc1bxYUV6TYAA6AArUUMJHLpgDgYAsOEMAQGAMxQAgAB9Wi6PouiIHieIJkAZoZdmOQAMKMAU0UaIY-jqIgciwE3I9QQhcx727JMmDNFVY0RZBr0PSSHxkuTlTfbMUAgWMIAAfmGCBtSYTAADcZUokA+IE+iIEAMYZAE6GQAJhkARoZdkcmzbNooSKNUTR0BHZpRM0gBRABHYho0RULH0wZ9dIgMRpTwTRkUETcEHQ6NAwjLpMFFYBiBYVRA1FfUwETZN5UVJoVQ3bSGSZWgizNC0rVQG07QdJ1XSCthPW9J1-SDFs8ujfV1yq2UarTaEMy0rVkU7FqTTassK1kls6wbJsWzbDt0SdUMez7chB2HUdkXHKcZznJNF2XelVzAddROYfzowPWE6vPbozFExlRQK76AG1yFip8WHBCKosDcFyUpD7tEDS90QxREoQxDGIbi58Yci6MEePJG1BRuldUxRE4Wx+EwAAXSsrzvIgQBCa1cRz7MAYYZAHWGZnbN8sBQHIa9AGPIwAVbw8KZAEhzOCEJYJDNRQtDMJwvDpQIojRFFCcZWI0ioDFyXAGjI+Z4MQ5DgFQ9DsNw-DCNgYBRSHYrRnFQ2IEAXQZXEANbkSlKc2Fct63VbtjX9bIiigA)

```typescript
type LookUp<U extends {}, T> = U extends { type: T } ? U : never
```
`{ type: T }`に一致する型を、Uから絞り込みます

```typescript
type LookUp<U extends { type: string }, T extends U['type']> = ...
```
解答を確認していて見かけたこっちの方が、型引数の制約がしっかりしてて良さそうでした


## Trim Left
文字列を受け取り、先頭の空白を削除した新しい文字列を返す `TrimLeft<T>` を実装します。

#### 例
```typescript
type trimed = TrimLeft<'  Hello World  '> // expected to be 'Hello World  '
```

#### 実装
```typescript
type TrimLeft<S extends string> = S extends `${' ' | '\n' | '\t'}${infer R}` ? TrimLeft<R> : S
```
スペース１文字とその他の文字列に分けて、再帰します

#### [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
TS4.1で追加された機能

JavaScriptの[Template litelal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)の構文で、型を書ける。文字列を変数にして、テンプレートリテラルで埋め込んで、文字列リテラル型にできる。

```typescript
type World = "world";
 
type Greeting = `hello ${World}`;
// type Greeting = "hello world"
```

テンプレートにUnionを入れた場合、表現できる全ての文字列リテラルのUnionになる
```typescript
type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
 
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
          
type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
```

TrimLeftの実装の様に、inferと組み合わせて任意の文字列を取り出したりすることもできる
```typescript
type Json = '{ "hoge": "fuga" }';
type Parse<T extends string> = T extends `{ "${infer Key}": "${infer Value}" }` ? { [k in Key]: Value } : never
type A = Parse<Json>
```
JSONのパースとかもでできちゃいそう

## Trim
文字列を受け取り、両端の空白を削除した新しい文字列を返す `Trim<T>` を実装します。

#### 例
```typescript
type trimed = Trim<'  Hello World  '> // expected to be 'Hello World'
```

#### 実装
```typescript
type Space = ' ' | '\n' | '\t'
type Trim<S extends string> = S extends `${Space}${infer R}` | `${infer R}${Space}` ? Trim<R> : S
```
左右どちらかに１文字スペースがある場合、それを除いた文字列をスペースがなくなるまで再帰します



## Capitalize
文字列の最初の文字を大文字に変換し、それ以外はそのままにする `Capitalize<T>` を実装します。

#### 例
```typescript
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```

#### 実装
```typescript
type MyCapitalize<S extends string> = S extends `${infer First}${infer Reast}` ? `${Uppercase<First>}${Reast}` : ''
```
テンプレートリテラル型と`infer`で、最初の文字を`First`、残りの文字を`Reast`とします。`Uppercase<First>`で大文字にしたものと`Reast`をテンプレートリテラルで新しい文字列リテラル型として返すように実装しました。

#### intrinsic
Uppercaseの型定義を見てみると以下のようになっています

liv/es5.d.ts
```typescript
type Uppercase<S extends string> = intrinsic;
```

これはコンパイラ内部に実装があって、型としては隠蔽されています。

intrinsicを宣言した場合は、コンパイラ内部で型の名前と型引数をチェックして処理されるようになっています。

以下の記事をめちゃくちゃ読みました: https://zenn.dev/uhyo/articles/typescript-intrinsic


## Replace
文字列`S`に含まれる文字`From`を`To`に一度だけ置き換える型`Replace<S, From, To>`を実装します。

#### 例
```typescript
type replaced = Replace<'types are fun!', 'fun', 'awesome'>; // expected to be 'types are awesome!'
```

```typescript
type Replace<S extends string, From extends string, To extends string> =  From extends ""
  ? S
  : S extends `${infer Before}${From}${infer After}`
  ? `${Before}${To}${After}`
  : S;
```
テンプレートリテラルを用いて`From`の部分を`To`に置換した文字列リテラル型を作る型を作りました。`From`が空文字の時に2文字目に`To`が入ってしまうので防ぎます。

Before, Afterよりprefix, suffixってした方が良かったかも


## ReplaceAll
文字列`S`に含まれる部分文字列`From`を`To`に置き換える型`ReplaceAll<S, From, To>`を実装します。

#### 例
```typescript
type replaced = ReplaceAll<'t y p e s', ' ', ''>; // expected to be 'types'
```

#### 実装
```typescript
type ReplaceAll<S extends string, From extends string, To extends string, Replaced extends string = ''> = From extends ''
  ? S
  : S extends `${Replaced}${infer Prefix}${From}${infer Suffix}`
    ? ReplaceAll<`${Replaced}${Prefix}${To}${Suffix}`, From, To, `${Replaced}${Prefix}${To}`>
    : S
```
前回作ったReplaceを書き換えていきます

テンプレートリテラルを使って`From`を`To`に置き換えつつ、再帰をして全て置換するようにしました。ただ再帰をすると、`ReplaceAll<foobarfoobar', 'ob', 'b'>`とした時に、`fbarfbar`と置換済みの部分もさらに置換を繰り返してしまうので、置換済みの部分は置換をしないように修正します。

型引数に`Replaced`を用意して、置換済みの部分はそこに入れてテンプレートリテラルで展開して、置換されないようにしました

他の解答を見ていて見つけたこっちの方が型引数が増えなくて賢かったです。アルゴリズム難しいです🥺
```typescript
type ReplaceAll<S extends string, From extends string, To extends string> = 
S extends `${infer Prev}${From extends '' ? never : From}${infer Next}` ? `${Prev}${To}${ReplaceAll<Next, From, To>}` : S
```