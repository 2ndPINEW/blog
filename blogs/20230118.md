{
  "title": "1日1TypeChallenges",
  "description": "1日1TypeChallengesして、型の理解を深めます",
  "icon": "/assets/Typescript_logo_2020.png",
  "date": "2023/01/18",
  "tags": ["TypeChallenges", "TypeScript"]
}
---metadata

## Pick
オブジェクトから特定のプロパティを抽出する型です

#### 使い方例
```typescript
interface A {
  a: string
  b: number
}

type t0 = Pick<A, 'a'>
// { a: string }
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsELQQAoEsDGBrS8491gRgJ4QCCAdgC4AWA9mcQGICuEAFAAICGlAZkwJQQAxIFwlQFi+wpmWR1h+JsgA2FOMjJgsQrREBXMYHlVDVEAivoH8GQD3xJwHYMgaPVAZwyAfhkBjDIGKGQFcMLgAYoMAHgAqADQQANIAfB6ASQyA-vKAFK6A2gyAWgyAgAwefh6A0gyAkQwewR6WgOsMgLcMgIsMLhGAvUaAX4qAmgyA0QzWEYD52oCjEYDqDIB+DNWAQAyGEIDR8oASDIAODIBY-70eExQAzlhqFACmAE48nKjzEH40ACY0EADeWFAUyBSK8wBcEFMUi2oA5ocQW-NTqLcADsd0l9e3ZA9QKCoGgAW3eZwWW0u+BoNDO3CwAF9ehRCO91psdohFvMAG7IeYAdwgAF4IABZQjedD+bY0IIAcmOp3mDIgAB8IAzgWCIfMtgzQr1gWRrhAKHTLpiaNi8QTiWSDoDAcyzpcGQBheFkCCLWEghkBR5A0Hg+aQy4rRRTeZGqDIqATDy9UIQADiJwAEkx8IBzBkAXR6AWKi6iMqBQKO8pudgMBpqgqAA6ABWUwTNEWd2A0GASc4YBAwA0oAgAH0y+WK+WIIBlBmrgGsGQDNDPZAJMMEUAGFGAU0VS5WeyWIAWNHMlis1qR9lhOD8bvcCJcyEwQfglmBkWBUejxQAGUlINA0kiMziCjTr9YUACMO-Q80INB4pBPaPWlOp-gg8wAHgsyFsphAaPgSbzKgFBBME75fvMP5-tet73n4rqKlgADaiAQGoIQALpSqhmErkWIDdr2FYQI4gCdDIAEwyAI0M9hkURxFlv2hbIGC6YUOKT77BAACiACOTCcIoQTcR+6IgRAiIQDweogly7CnnA8aCWc-wvMATDHNaDKPhuqCcDaf5kshWAiWJFA+HxAmKBZonAZC55BC+e60jsjKqqyoSeXaPG2SBFn8YJNlmfyABMjlUs50puScZxspy3KmnyAqeaE3kxhA8lTHAn5mdlix6osWBOb4UVcu5cVcjyZqQhVDJqLignIMlRp4WAQ7LKsGJ0uORwxRcVzTv8WDPK8HxfGQU5-ACEBVUl0Kwtq+FtZQw6dT5wVbJeSrin1k0zqu7Ujuspl2aFPU7Sye1DSavLmvy81wvMCKrsWDEkYAhNaWGRjiAMMM+T0QxTFgKAWCuoAx5GACreESAI6KgCQ5iGYYRlGMZxomKZphmWbANwUyEksOZ5lA4NQ4A0ZG1KG4aRtGsavGjqbppm2ZTHCGkyKKoMQIAugyWIAa3KWIATVGADIZFNI9TqPJvTmO5vmhZAA)

```typescript
type MyPick<T extends object, K extends keyof T> = {
  [P in K]: T[P]
}
```
`<T extends object, K extends keyof T>`で、引数Tがオブジェクト、引数KがTのプロパティ名をユニオン型で持つ必要がある物として定義します。

`[P in K]: T[P]`の部分が、Kを反復処理して、Pにそれぞれのプロパティ名が入るので、`T[P]`でプロパティの元の型を取り出します

#### [keyof](https://typescriptbook.jp/reference/type-reuse/keyof-type-operator)
オブジェクト型からプロパティ名を型として返す型演算子。
プロパティ名が2つ以上ある場合は全てのプロパティ名がユニオン型で返る。

```typescript
interface A {
  a: string
  b: number
}

type t1 = keyof A
// 'a' | 'b'
```

#### [extends(型引数の制約)](https://typescriptbook.jp/reference/generics/type-parameter-constraint)
型引数にextendsキーワードを用いることで、ジェネリクスの型Tを特定の型に限定することができる

以下の例では、`T`が`HTMLElement`であることが保証される
```typescript
function changeBackgroundColor<T extends HTMLElement>(element: T) {
  element.style.backgroundColor = "red";
  return element;
}
```

#### [Mapped Types](https://typescriptbook.jp/reference/type-reuse/mapped-types)
`in`がユニオンで与えられた値をforみたいに反復処理するイメージ

```typescript
type SystemSupportLanguage = "en" | "fr";
type Butterfly = {
  [key in SystemSupportLanguage]: string;
};
// { en: string, fr: string }
```


## Readonly
`T`の全てのプロパティを読み取り専用にする型です

#### 使い方例
```typescript
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBDsELQQEoFMCGATA9gOwDYE9J44TSiAjfCAQWwBcALHKgMQFcIAKAAVXoDM2ASggBiQLhKgLF8x5NgEtcdOHOxiATmix4qozOQBWyAMZKA1snwBnMEVF2IgK5jA8qo2ogEV9A-gyAe+I+A7BkDR6oBnDIA-DIBjDIDFDIBXDBEABigYOAQAPAAqAHwxgEkMgP7ygBSugNoMgFoMgIAMMSkxEL6AmgyAngyAZgy+gOsMgLcMgIsMEZmAtVEegGvKgFEMgEA6uYDWDFWA0Qz+mYD52oCjEYDqDIB+DFWAQAyzgKoMgDEMgPoM-k1tEYD2DICxioBOSn2Ayvp1gOYMgLIMC-mAyQzLrhCA0fKAEgyADgyAWP8vMf90axQFR0ZBqfioIzICApTBYCAAbyIUDocjouGQAC4IJY6GoVABzZEQdDISxGfEAB1ROGxuPx2CJUAAvi8jDhcRA6HDMNiALL4eJaZKwrBpCAAXkRxNR6KxEAARAAJCwKgA0xNJ5KpNOw2IV-EwelQagVRFZRG5WAAdLKMZLFSrcLhMAqIMBgBAAKJqNSYNTYox8bCYOgQDSoSyWOQE1SocOaRJUSl+ylguiEFE861ailyalyHAOhXkE0sI1uj3e33+wPB0MJyPR2MQeMR4XJ1PpzMQf4xF7igDiaKVbHIV0AXR6AWKjxt8GHQ6JTLJiPYCjAxrfpLNb-QTgNBgPpUGAQMAbKAIAB9a83283iCAZQYH8NAM0MwUAkwyZQAYUYBTRSvd4Ay8IFPGwMzTCABSFJNUggZAAA9QWwdBLAgPRDBMcUpSRKB2yTCAAG0AAUIBUCBzHwTB+BhABdbEUiI6iwAtC9AIAiBQkAToZAAmGQBGhmCDj-1Y+8QLkABbSl-TDMDoQRb0AEc2FQXA1W9OC0xMCBmQgfg-VEiAAHJuGkuB1yUjFGTJYA2FRXBLH00D8HAoNLDJB18KIL01OMOgki9BSlKSSDE20VIeQARjSFSoJC0VMAitJIrARiwBBMEIShGFwulFE0QxOk8UJIhcx1Qs9RxArGSIdlxIxUF0GxcgjQxPgiFE5A6FQbFsKgVtrKYANyoZJlNKY88QEEoSgMAQmtfA40JAGGGRoJqE4Cz1AIhxUAY8jABVvTJAEdFQBIc1nedF2XVdyQ3LcdzUPcDz4SwAHcwUPY8oC23bAGjIsY5wXJcV2ANdLu3Xd92ASxMFwazSqBCBxUAXQZfEANblfEAJqjABkMn7Tv+wHN2Bm6XpPM8gA)
```typescript
type MyReadonly<T extends object> = {
  readonly [P in keyof T]: T[P]
}
```

`T`がオブジェクトで、`T`の全てのプロパティを反復処理して、そのプロパティ名を`P`とします。これを`readonly`としてマークして`T[P]`で元の型をペアにしました

#### [readonly](https://typescript-jp.gitbook.io/deep-dive/type-system/readonly)
インターフェース上のプロパティを`readonly`としてマークすると、そのプロパティを読み取り専用にできる

```typescript
interface Todo {
  readonly title: string
  description: string
}

const todo: Todo = {
  title: "Hey",
  description: "foobar"
}


todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // OK
```


## Tuple To Object
タプルを受け取り、その各値のkey/valueを持つオブジェクトの型に変換する型を実装します。

#### 使い方例
```typescript
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCM0QtBAKgVwA4BsCmEAuB7CAeQCMArLAY10gXnodpIE8IBnASwDt98uIAFAAFOPPgEoIAYkC4SoCxfafnJVc8ANZZmbMLSl6IgK5jA8qo6ogfoZA6wyBrhkBJDIHXlQIoMgNeVAUQyBABkC6DIDsGQCAqgEgUvDWZgADcAQwwULBtAQGNAEwZAKoZANYZADoZAcoZAeoZACYYvQGj1QGsGQEhNQG3jQE0GQGiGXJtAfO1AUYjAdQZAPwZSwCAGUwhAaPlACQZABwZALH-2gANh3G0oSj42XDx0bAgAXggAbQByXCw2DDCVgBoIFYBbfAATLAwIAGZd-aPT84ANa8OTs4gATRWAXQgwtggJrhTdq4ZhoHAAJw2KAw00WqEwWCQ+FIFGoAB4QWD8AAzGYIgB8EGAwAgWAAHmDqFhjhAAN54DZbABc+3Wm22e2ed0uKxZXNeV05t1ejz5woeT3F715Nxe5w+AF9aMNBu1CQBxDi4AASKBIgHMGQBdHoBYqIqfQAFrhcGg2EziaNKOaAHRkNhO-DggDmwFgwDIYTAIGAOlAEAA+hHI1HIxBAMoMsfygGaGQA-DIBJhhsgAwowCmiuHo3mwxAg2BMTh4dgkSiVGikKSyesuMc-pCwsc+BhWGEuMwlp9CYs6bQlgAFCDcZBLLgoA4kLDgz6fFlDsBK4ugnCw5CzRHI5Toks4vHYfEhkC5-NRiCAMYZAJ0MWUAjQzJ69n88RwvBjgHNAe6YlukQACiACOKARHs-4UioEAKhA2LgvgBz7EIJbwI6ETYFwnobMAKC4BwGBsCsOgAlMh44IsqxslskpyjyQo0Y8dHch83y-P8kw0MRP5bgAclOM7ggsyzQHsABMewXHsAAsLF-JxYCcaRACyHBkoJSzCfsInXBJ+ySV8PyyexOi-pQvwbGptDgZSuBokBIEYNWW4VruNn7riuBbviez0pRYR8r5KwANyytyVxijRVzBfyErhdyjxRVKHyxa8HxQfiXmWRB6J2REjkIs5qKuWuB4eQivHTrOXl-tALLQMFIksiJwUXCyFzBZJLKSWlGVQFZVY5Q5ZbbpWe7Fe5W7KWSVX0jVMBRVpfJac1rVRXpfJ6d1OxgJ8IYkkhbDwOS1mHeCcHgquYKkqdHqCUNBVVks6miZ83kKr2J7Pi+ECAITWXjXpegDDDBYn3nm+YCgLQhKAMeRgAq3jYgCOioAkOZmpa1q2vabCOi6boet6vqdmwADus5+gGUDQ3DgDRkeUFpWjadrAA6zquu6Xo+tAwBsPgkS4ZMkMQN4gBrcl4gBNUYAMhm02jDNM9jrPev6gbBkAA)
```typescript
type TupleToObject<T extends readonly any[]> =  {
  [P in T[number]]: P
}
```
`Tuple`で渡された型を、`T[number]`でユニオンにして、`in`でプロパティ名と値として展開した

#### [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
別の型の特定のプロパティを検索できる(これは今までも使ってた)
```typescript
type Person = { age: number; name: string; alive: boolean };
type Age = Person["age"];
// expected number
```

配列の要素の型を取得するのに`number`も使えるらしい。覚えとくと便利そう
```typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
]
 
type Person = typeof MyArray[number];
// type Person = {
//   name: string;
//   age: number;
// }
```


## First of Array
#### 使い方例
配列`T`を受け取り、その最初のプロパティの型を返す`First<T>`を実装します。

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAsEFoIDECWAnAzgFwgewDMIBBddAQwE9JEE76aAjSkgO2wAs9WXkBXCAAoAAuXYE+ASggBiQLhKgLF9Z5MlTA0ZmiICuYwPKq6qIFlEwOhKAAwAqpwEkMgdeVAigyA15UBRDIEAGQLoMgOwZAAOZyPgdYZAW4ZARYZAMYZAYoYPQGj1K0AV+MBNBlM0LGwAHnMAPmtAfO1AUYjAdQZAPwY4wCAGAwhAaPlACQZABwZALH+y00bsTBpsSgAHAFMIFXRoCABeCABtAHJyUYAaCFHGKZmAY1GAXVaO7t6AJkGRgGZpzenoVbWuiA5O8gATfqGknBTe6HSIYGAIToAPLoXsTquINg8BBGN1xqNTt0LtdtncMA8ti83h9vp1fv9AcDQRBdjRGqYyi8AOKobAACT4jEA5gyALo9ALFRcUA0Qy1DjYbDtTAALjezQWHAAdAArTD8vDoADmwDgwEF5DAIGA6lAEAA+mr1Rr1RBAMoM2sA1gyAZoZAD8MgEmGKyADCjAKaKqs1tpVEAVYDaZ3uqXMKL+rCumB6PGGyxeQ3dX093pGYko0350Yj-uWEAA-BBzMMAAzxzkQVidABunXQSpANrtGogIUAnQyACYZAI0MRvLxZLaoditQAFt2mLcM7ugBvCAAUQAjnxyAAbab91G-CAAXwgBHQeFbM2E3YQfLHo86rHFnUwwD42FQo8wEKd6wgC3ImD3O2GNEnP1SQ5Ho5SrpSw32EEOMAD012dJ0kmB8p2fYcx3feFUmGQRpAGF5oE2b8+3ITMcHQVAd1nf8hHgxDkKAkCoEfNFwNfKDkk-XDszzdAiNAp8UhfSCP2GPgvU6AgsP+XCOKuLieKuBiTm7D4yDFH0hnvKBkVXTAEC+J9FIkgsoA-UZWDwbBSAoShRmAmg5OaRSwJUxc1JQaCUj7VNM3GVRKAAGVQABrTpRlnQyTmVRtS0AQmsPHLEJAGGGPwG0bZswFAGgXkAY8jABVvKxAEdFQBIcyZFk2Q5blgF5AVhVFCUpVgYAxEwAB3fMZTlKB4qSwBoyOZVl2S5HlMD5IURTFSVpUwPBR0PVBuBaWqIE8QA1uQ8QAmqMAGQzMpanK8s6wrJVleVFSAA)

```typescript
type First<T extends any[]> = T extends [any, ...any[]] ? T[0] : never
```
`T`が要素数1以上の配列なら`T[0]`を返すようにしました

他の回答見てたら`T extends [infer first, ...any[]]`ってしてるのがあった。こっちの方が賢そう

#### [スプレッド演算子](https://typescript-jp.gitbook.io/deep-dive/future-javascript/spread-operator)
Firstの実装ではスプレッド演算子の、分割を使った
```typescript
var [x, y, ...remaining] = [1, 2, 3, 4];
console.log(x, y, remaining); // 1,2,[3,4]
```

#### [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
型の条件分岐を行います
```typescript
// `T`が`U`に割り当て可能なら`T`、割り当て不可能なら`U`になる型
type A<T, U> = T extends U ? T : U
```


## Length of Tuple
タプルTを受け取り、そのタプルの長さを返す型Length<T>を実装します。

#### 例
```typescript
type tesla = ['tesla', 'model 3', 'model X', 'model Y'] as const
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT'] as const

type teslaLength = Length<tesla>  // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAcEFoIBkCmA7A5gFwBYQHsAzCAFQFcAHAG1UkQUafoCMBPCAZwEt0CD0EABQABHnwEBKCAGJAuEqAsX1nYqtMPRmaIgK5jA8qrqogfoZA6wyBrhgAGpc4CSGQOvKgRQZAa8qAohkCADIF0GQHYMJ058DuqYCqDNaAK-GAmgyA0ermaFh4ADykAHw2gPnagKMRgOoMgH4MoYBADAYQgNHygBIMgA4MgFj-+eZV2Jz02GyUqBDYqJzUAIYQALwQANoA5C1t7f0ANBD9ALYEACao1BAAzGMT03MLABorU7PzEACa-QC6dQ1NnJTtAMaoG919-QBiAILIAMIA8gByEACc2y93t8IAAJACizwAaodxv0ACIAJWeAHFvtsAMqkZ4I9EggCSAAVtiCAKoAWWeP3RBOebzBj2QeORINIx3y9UazVaHWiOHwPV5cSGHQSUGAwAgqAAHo0ri0ZhAACynTkXa63QX8lAYPmxNU3Dai8WSmWoOWoBUAVnoVXM+VFyO42BB5BYgHMGQBdHoBYqNCgGiGMq4bDYSicABc4pqV1wADoAFacaMEABOmGAcGAsfaYBAwHUoAgAH0i8WS8WIIBlBnLgGsGQDNDIAfhkAkwzWQAYUYBTRULpc7BYgOfUHKamviJpa6BmnAgSdQ7RmAmoHHa6DYvSOop6pAGtBiuDZYHzXc7EEAYwyAToZABMMgEaGOvHjv7su97iTSjJ7DNM4QADeEDBAEdyO1qOMYKmnKEAAL4QEQSYEJMEwiP2CBRv+m6YK0wDkNg3DUJw-TqFcAicC+wqdD0AxEdsax7MssIUZs5G7AshxHBA7Tjnh6AEWAbEEVwlwGvcAyAp8Pz-LCgnAuCUIwhMiIomisKYtiuKEsS5KUhA1K0vSjLMqyTEsRAXHYH2b5XCxrT8fQQGytgsQ-n+1CxIO-bEFywwJOMioJO5lnATZdn-o5OpCmcLn6rc7kQJaXmjPQxpwZwCDStZiVJlBSb0IOUUxWKErxYlvkpWlGVBbgsT9Lg8zUAQEAAO7JtQMz9N5Jy7iAN63t2gCE1p4x6HoAwwzGO1t49rmoD0KKgDHkYAKt7WIAjoqAJDmfoBkGIbhsAkYxvGiYpmmsDAAunA1agSYZlmUCTTNgDRkf6gbBmGEacFGcYJsmqbppwBDUOh3D4eNEBeIAa3KeIATVGADIZy13WtG3PdtqaZtmuZAA)

```typescript
type Length<T extends readonly any[]> = T['length']
```
`ReadonlyArray`は固定長なので、lengthプロパティが定数になる？みたい

## Exclude
組み込みの型ユーティリティExclude <T, U>を使用せず、Uに割り当て可能な型をTから除外する型を実装します。

#### 例
```typescript
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAsDMEFoIFEAeBjANgVwCYFNJEETSiAjATwgC0ALfRgOwHMIAKAAQC8HmWAlBADEgXCVAWL4jy2AJaYALghlMR2JjID2TMEWF6IgK5jA8qo6ogEV9A-gyAe+IuA7BkDR6oDOGQD8MgMYZAxQyArhg8ADNFjx8CAAeABUAGggAVQA+H0AkhkB-eUAKV0BtBkAtBkBABh8on0BrBkAnJUAohkBlfUAzBkB75UBfgMArBnt4n1CfQGkGQEiGQBM0wDRNQE0GQGiGesB87UBRiMB1BkA-Bm7AIAZTCEBo+UAJBkAHBkAsf5mfdfkAZyJ5SgAHIIAlfE3sBQgAXggAWUp-HAJggHIAQyeIAB8IJ-J3r6f0E9Iq8njEIMBgN9fp9voCiOsfDMwQBxGTyAAS2HIgHMGQBdHoBYqL6yzo8nke02AC4IVt0HQAHQAK02dI0ACcWMA4MAGS8wCBgDpQBAAPqisXisUQQDKDFK8oBmhmcgEmGeKADCjAKaKIolWuFEH5YF2BxudwwD3wYUisUuEFCEHwqHk+CYuE20QgAH4IEx8AA3fCsiAU62CkCa7XiiCuQCdDIAJhkAjQzOSOhsOi3UCmQAWz2bPkEANQQA3igAI7YF6YSJoA7oHMAXwgADNWRp099OHmELSy5hHSwTsBsPI5Jsnjo8xB0C9NicrQBtIiV-DV4LIEtl4K3e6BZ5vGE-P6woHfN4xYHQ-6AmIn+eoKvyZerzDr40BR4g3dng-Anf-X4ng+X8Jr1ve9S0fDcTS3TZ5FZZQ2C+JhsHTcg-Rhdh2CEC4wW9DQZFwARIgAMTUatNCYP8oJg1gYQQpC-QAsAAF1gyTZMIEAQmtbEjVxAGGGQB1hhYsNUzAUAiDBQBjyMAFW94kAR0VAEhzIkSTJSlqU2WlGWZNkOS5F4mE2AB3P1uV5KBxKkwBoyN6YlSXJKlgBpekmRZdlOVgYBNg0HBBy0bYTIgQBdBlsQA1uVsQAmqMAGQyrKU2z7PUpyOR5PkBSAA)

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

`T`が`U`に割り当て可能なら、値を持たない型である`never`に、割り当て不可能ならその型を返すようにしました。


## Awaited
Promise ライクな型が内包する型を取得する型を実装します。

#### 例
```ts
type ExampleType = Promise<string>

type Result = MyAwaited<ExampleType> // string
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAcCcEC0ECCB3AhgSwC4FMATSZJM8kgIwE8IBZTAY23wCsIBlbAawHsAnTBAAUAAQC2TFqwDOPAZgCUEAMSBcJUBYvqoAO-XuOwz8qygFdsAG1xJsAOzAkVTiICuYwPKqDqAAU9BoxEBLhkAShkB6hkArBkBo9UAZBkBQxUBQZUBNBkBohgjAJIZASwZAOwZACIZAMQZAawZANeVAdP0EwBiGQAcGbMARBkBzBkB1BkBwhlzAaQZAIAZPCEBo+UAJBgrALH+AAx99Q3wAHgBRAA9McW0LfAAVam18AD5BwAsGatzowCEGJMAWDUAIFUBABiy8-PrAMwYIGbmF5dXjVJLyqrqm1o6SQf-cDISLgXvdZvNFis1hAALwQEZ+CYyXD8OwAc3WnRB0IASvgZKYrLD6NQMDgCIQpuCnlCNhBgMAIMjUbY0X9-p11hBAMoMmTcgBkMzKAYUVABhRgGi5QD2DBAANoCbBouyYCwQTD8XDYRiLAC6wgAFrhcNoZAAuBmEfAANwAdLheMBJIw5HxBMBMIQLZhbIwiEhsfjGKjtNZ8NN8PxmEYZEgAI6mfHq3i2JDQJAAFgArNxU8oaDKJFI2E6FDr9YaTQyFbhdaZKFbGPp7QXZPJBMpaglflAuQBxPAACRrtUAXR6AWKjkv1S0bTcBAYxdVbZFaBGjgHB4MBWJgwCBgA5QBAAPpH48n4887n5QDNDIAfhkAkwypEWAU0VD6fXweIDuwH6SWS8ERxksEAhgQtiEDI8K+GMAAyPATJ61DrFyMIkIBwH4KB4EItBsHjHYABmYYQAAqpiUBQAA-MRQHTCBYEQaMRgwdwcG2AhJBkRAlF0KSWB-pSJHsWRxrEYJwm2JaYZ7iAL5vieECAGMMgCdDIAEwyAI0M16KTJslHh+u7YPMAi4BA34AN73LGSoADRgmsjBGQAvhAeG+BAADkoh+kgc5KosrL4sApjqhYMiuQ434ABrElhRjjMy6KYt+ACaUWQTFZl4SwFiEGJpjiJQhH2QloIAFopQxEzRUiKLohAAA+EC2Ll+X8IhX4ldAZWIuMlXdalVUsmidUQJQvC8IsnqIUV0KAXCZlVuhwnCImeGEhlFiLNlIiqmiOV5WGygwly8EHUdrEQPZYWgowmCRsS0okDMtm4FMFkWOM3G-hS4zhes1lxayiGWQ90xPS9phKu9PHkv+iW-RA6WZZtjV7fw52A8DoOTK9kOff+xVw-9g31cjzXo1Aj34HZYMQx9vFfcV0AE9VrJDSNY34BNv0Y5Tz1Y+Db209DlJLHDJNhujWp7oyHlRiGT1IGGej8G10KKwIxKC3x4xiy1UladpECAITWmSKfJgDDDIA6wz67JulgKAJBcoAx5GACreqSAI6KgCQ5uOk7ljOMhzguMhLvwK5rq6tgyOgYYbluXYQC7qSANGRSQTgaU4MrO86Lsuq4IMAMhjYF2CJkCceALoMmSAGtymSAE1R-Kp2W06Z4Hwcrpu267kAA)

```typescript
type MyAwaited<T extends PromiseLike<any>> =
  T extends PromiseLike<infer U>
    ? U extends PromiseLike<any>
      ? MyAwaited<U>
      : U
    : never
```
`T`が`PromiseLike`(Promiseと同じシグネチャで実装された何か)であれば、それに内包された型を`U`とします。
さらに、`U`が`PromiseLike`であれば`MyAwaited`で再帰的に`Promise`に内包された型を取得します。`U`が`PromiseLike`でなければ`U`を返すように実装しました。

最初、`PromiseLike`の部分を`Promise`としていたのですが、以下が通らなくて`PromiseLike`を知りました。
```typescript
type T = { then: (onfulfilled: (arg: number) => any) => any }
type a = MyAwaited<T> // expected number
```

Promiseのシグネチャを独自に実装したもの向けの限定的なインターフェイスらしいです
[Qiitaの記事](https://qiita.com/jamashita/items/7abcd0693dadcef2afb6#asyncawait-%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%97%E3%81%9F%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%9F%E3%81%84-)


## If
条件値`C`、 `C`が truthy である場合の戻り値の型`T`、`C`が falsy である場合の戻り値の型`F`を受け取る`If`を実装します。

#### 例
```typescript
type A = If<true, 'a', 'b'>; // expected to be 'a'
type B = If<false, 'a', 'b'>; // expected to be 'b'
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBBMBsAcEC0ECSAzSyk91gRgJ4QAKAhgG4CmANhAOI0CuAzgBYDWA9hRABQABAA5l2TAC4cAlBADEgXCVAWL5yJASxoswWWToiArmMDyqlqiBDc0BvcoBIFAAYBhK4EAGCLauAZBgjiAThLbFA5gyAhBkBohkAWDUAIFUA7BkBuI0AohgtwwGj1KwAVB2c3dDINPyCwqNiEqwAxK0AkhkB15UBFBkA15UCrDFLAfO1AUYjAdQZAPwZATQZAIAYsc2s7CEB7BitPJiorQGkGKwyNcfDASwZAQwZASIYJgMDAZQZACwYXQHxzQFD9QFUGQBiGTpd7ZKsILadiocBvuUB4QwSSrc2d30BZBk6erEBo+UAEgyABwZAFj-xicVhGmig4kIQioEAAghAALxodAAHlGVAANBAAORkfF4-H4fEAPgA3BBgMAIFQAB7wgDG4ioABN3FwIPgEYT8VhYfCIAAhVHojEzFi4glEklkqk0umMllsznibm8glkrCQqzg8kMVTiAASTHwvkAXR6AWKiOoEQWxxOIhCwAFy08QsZlsAB0ACsWD6uB4AObAODwYB+shgEDALSgCAAfRTqbTqYgGw2gGsGQDNDIAfhkAkwwlQAYUYBTRWT6arSYgcbAQoRGAxNnpDLZADt2SweVwuDQqGR23iknjCoa0S3GR2u+4vAiAPwQJIQV0QQoJkCV6tpiCAMYZAJ0MgAmGQCNDPn91vtyna-HVABbITB8TuOEIgDeEAAogBHJiZPEfpkqFZCAAF8IHQDwuFvAkBAbJBvUyft2xDKgWGANQNAFesXwgZlRFQ8UAG0sAA1UMW-X8aAxJtsRJOVtQpOiKXJHESMA1lyJ-TJqMxKUZX5PFoBYmByRYsAAF0EzpWCWCQFUgPEOSPEgjxsOFKhlODcUm3bJgaBoJj5QpDcL0vCBAEJrcJ913QBhhkAdYZTO3a8wFALBDUAY8jABVvEpAEdFQBIcztB0nRdd1gE9b1-UDYMwwjYBBxYAB3DSoxjKAPO8wBoyPtR1nTdD0vV9AMg1DcMEGAFg+zULh22hCBDUAXQZwkANblwkAJqjABkMoLctC8LCqikro1jeMgA)

```typescript
type If<C extends boolean, T, F> = C extends true ? T : F
```
`C`が`boolean`で、`true`なら`T`、`true`でないなら`F`が返るように実装しました。


## Concat
JavaScript の`Array.concat`関数を型システムに実装します。この型は 2 つの引数を受け取り、受け取ったイテレータの要素を順に含む新しい配列を返します。

#### 例
```typescript
type Result = Concat<[1], [2]>; // expected to be [1, 2]
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=20&ssc=71&pln=20&pc=1#code/PQKgUABBCsDMsQLQQMIHsB2BjAhgF0iUWJMICMBPCAQQwBMAnAUyoGkGcBnNAN04GsqACgACZZrAAM-DgDYAnFk4BKCAGJAuEqAsX3U4GHCmEJqTEQFcxgeVUjUAFI4eOAMpYGASwAOeCIDsGAAbV9HAoAOixMXDxfQCLUwAdTQCSGQGj1QHaGQE6GQDGGQAOGQGsGQHztQFGIwHUGQD8GQE0GQCAGQGUGbwTAewYIACYIQBMGb0BUfXjAdeVARQZANeVAKIZAQAZunsBjBkB9BkAShjTAG4ZAH4ZAfoZvQEDIwAJfOMAwDKzAahVAAIZABtMCwBEGQFlEwHQlOMAV+OLy6whAaPlACQZABwZALH-b3w+8TkI8CncmCAAJSYnAArgAbLwAXlQ4XwAB4ANoARgAugAaCCI+qogB8AG4IMBgBAmAAPf5YPBMOgQPBoCBkAEozE4wgfXy3XEQADirjwAAlQWRAOYMgC6PQCxUSVANEMLwAFng8O5OAAuYlfLBy4IAK04wTQDAA5sA4LBgNqcGAQMAjKAIAB9R1O51OiAVCpZQDNDLNAJMMcUAGFGAU0UHS7Q-aINawL9-rDsAiACqksnU+icGiBCjwnAYCi4zEAVSTKboaYCBizOdx3JhiOCdfjmLrwXzqNtIBDYedEDSKUAEwyARoZZikO53HRGba4ALbuA1eaMAgDeEAAogBHUE4cGY5cUphUiAAXwgADMGGhJxAAOQieeITWb8FMDCGkHAUF4VzgziXozziC4TgQQgGtCB3Sk8HhNcN3BeF0DjCDEQxLE8UxRCq3RUDdypSD103WC4QQpCURQrE0XQzDwJw6D8PgpFkVZIjYExAAWEiWQaTEmIgVjyKgMC9wgqC8LgiIkUvZFL1ZTFL1gS8iOPTdAMxMg0DQR9s2k5i5LzLFxMkjir1kzEFK-JhlNU9SME07S8zAVswDtUcu0AQmtvHSQBhhkAdYYR1HccHPAKBuUAY8jABVvOJAEdFQBIcxleVFWVNVgA1LVdX1I0TXgYBs04AB3JgGHNS1AogUK4kAaMjZQVJVVXVThNR1PUDWNU1gG4cF31cTBviKwBdBm8QA1uW8QAmqMAGQzYqqhKkvq1LjQtK0bSAA)

```typescript
type Concat<T extends Array<any>, U extends Array<any>> = [...T, ...U]
```
配列`T`と`U`をスプレッド構文で結合しました


## Includes
納得いかないから今度書きます
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBAcCc0QLQQJIDsDGAbArgEwFMBnSJRci0gIwE8I0cssIAKAAQGsa0CAzHDgEoIAYkC4SoCxfUQEMATrOk0wpEaoiArmMDyqsqgApaQDdpAZQyyAlgAcALoDsGAAYBBeYoB05zLkL3ARamAHU0AkhkBo9UB2hkBOhkAxhkADhkBrBkB87UBRiMB1BkA-BkBNBkAgBkBlBlsgwHsGQEAGACYIQBMGW0BUfUDAdeVARQZANeVAKIYC+2tZHAJ7QBCGe15pLCJOgMAvxUBspSTAKwZawBiGQAcGCcaUwG0GQGSGDJ0IQGj5QAkGWcAsf437I+sSKGsaSwIIcyIABXMmOQBZAjQIAF5UT3xiAB4AbQA5ABpOREQEAGgggIAokRzHgbuZIdCAOrSAC2OBwKMBxmkaGsBOkgIAulDAQARcwAe0BAD4IMBgBACAAPS4YawEPAQaw0iBUK69fqDeykI7i0iMgDi5msAAkcFRAOYMgC6PQCxUWlANEMewAFtZrJYiAAuZknDB61wAKyIrhpsgA5sA4NBgNbpGAQMBlKAIAB9QNB4NBiBZLIxQDNDIAfhkAkwwBQAYUYBTRQDIbT-og3rA50uX2wPyIvwAKqy2dy0HgiBBZARpHgaWgsHQCTR-uSIABVRmfEvs8uViD-Dy8AiyCAAMXMsiI1ihrnnw9HEAASsRrKTSAB+CBPGgwgCOOH6v0n09nncZfdeA7aHVIUG3t4I94gJrzXj+q5nUK7pDffQGZ9swuK5dwPI8sF+AANKEAE1u1YYt6RYYR3kZXsy2vKsoIgbcAEZXwgIphCvCsqxYJCUI+dDS37KtYNwiACLfYitz5dpnygf9RSAv10zTCAIjCQAJhkARoZozCVN+NDLNzAxSwHWsPkQIgABvCBwP6KEYQ5AguQgABfCBeFkGkMWhNgcwIRBLX6LBXkdYhgBwawHnBZQrIgDBpEGKtPn+UgdM5axfk0yD0HzQhCyBUFp1xOEESRXF0SxHEKXxQliTJClYvBekoSfel8sC3SuVCw9jwij9opBMF4vhRF4WSzFsVxDKiTQEl2ypWkGShADBiKiESuC8qIN+KqCwBPCoSKKEAGYoQAVihAA2KEAHZ2w2-L2I6IaRr0kKwom74oum2aFuWtbNvbAAWXaBoIA6oCCo6xsqs6-n+GaiIW9sil2write0rjoq8Kvui365ogeb2zwoGOJejSwY+yHIu+1SDPbdTpDfQFHEBQzHp4lG3rKk7JvO-4qBpGl7IJS64euiB1ogLb+rJrnAPJtGqahgEn2ZxaIBWtnbqhOmGdrNBSd5kHUdGgXMeip6RdZ9nOeM7m9uexWKfB8bqaxiB8ehInDNx6ta3rRtmwJy2DPlwaDf5iHTtVgF1JrOsGybM3HeJnGoTxoOSZ513htB5WPZN6GEYgAAfIiXf16OlfelXqum5OiIRtO+dj43Bf+BgmHbHAKz4DweULt3i8+r3-irwheFrvB23LrB6+GjcwD46TQ0AQmtbEiQBhhkAdYYpKHzMfVAaUIEAY8jABVvAJAEdFQBIcx1fVDWNM1gAtK1bXtJ0XXgYACSIAB3Ud3U9KBGVXgJAGjI3UDSNU1zSIS0bTtB1nSumAEQBmLlaRoFOBARkgBdBlsIANblbCACaowAMhm70-gfI+f9T7Og9F6H0QA)


## Push
`Array.push`のジェネリックバージョンを実装します。

#### 例
```typescript
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

#### 実装
```typescript
type Push<T extends Array<any>, U> = [...T, U]
```
`T`をスプレッド構文で展開して、`U`をその配列の最後に付け足しました


## Unshift
`Array.unshift`の型バージョンを実装します。
```typescript
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
```

#### 実装
```typescript
type Unshift<T extends Array<any>, U> = [U, ...T]
```
`T`をスプレッド構文で展開して、`U`をその配列の最初に付け足しました


## Parameters
組み込みの型ユーティリティ`Parameters<T>`を使用せず、`T`からタプル型を構築する型を実装します。

#### 例
```typescript
const foo = (arg1: string, arg2: number): void => {}
type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]
```

#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=22&ssc=103&pln=22&pc=1#code/PQKgUABBDM0IwCYIFoIAUCGAnDBbApgC75YDOkKyV1FARgJ4S4CWAJgPZbMBe+LEACgACLDl14sAlBADEgXCVAWL6zmAOwBmJWYQCuABwA2+WbW3N9hZKrAUZtiICuYwPKq1qIBFfQP4MgHvj3gOwZA0eqAZwyAPwyAYwyAxQyAVwzhAAaYOATEZAA8ACoAfNGASQyA-vKAFK6A2gyAWgyAgAzRKdGA0gyAkQyA-QyA6wyA1wx+mYDTloCT3oCaDIDRDM2A+dqAoxGA6gyAfgwdgEAMLhCA0fKAEgyADgyAWP+T0SuE5FAAxuwqpIQQauzsEAC8gtgA5nAAXBC7XCrnADQQFwg3Ktq4tCSSNwBu7DYJzSEAA3gBfSaEei6IwAMW0Kg2hGY2zieFIKRhRlOAFl6OiEiRSElobD2Gp9ocQcBgBAANoXa63Qj3J4vLDnN4QD5fEgAXQoK2ikxBAHFmIQABLaWiAcwZAF0egFio7oLAAWhEIulIV1paw2aoAdAArUiGzjnYCwRDAY0YMAgYDWUAQAD67o9no9EEAygw+wDWDIBmhiCgEmGTKADCjAKaKbq9sddEEdYDJRnxhKIxNSEHwAA9iCpWKRBIbixcdS8VPR6fzpMcQRgKyDTiks7n8PnCwJi4bSzdVBosBAAKo1usViAAfiHEHe+D+JGdIBjcc9EBCgE6GQATDIBGhiCa6Xy-dCadzFwuk4e2TYIgAFEAI7aDD6Z7X7Ow5EQcH7LDsXAQADkQjJsgBqPoYDz4KQwDaCi+ikH+1hbDsewHEcpwCEyNx3Ko7KvO8nzfFgvwQACQK1mCkKIbsEC0NgJxnJyzK0Ichj1s8uFXhgNx-gAgn+H5ESRrDAuRYCUXsNHcHRAgCYCQlkRC1iXhsGCkBBdH0hQL5voQSR3g++hJKm2B4OmyTJhSVLsGkzz0lhDzPLyBH8mk1maa++DIrp96PoZBLGUSZnYhZNFYNZDJMewLEqM8oIvFxvEfs5rlQFpHk6XpPlGfEpkkuZlISWFVYuY8YCCmALoHiugCE1j4a4hIAwwx1PuB5HuV4BQCCgDHkYAKt6ZIAjoqAJDmqoalqOp6qQBommaFpWvACDAPWpAAO4kLa9odRAPWZIA0ZFdOqmrarqwD6kaprmpys02qQkXQaiOwUCCgC6DD4gBrcj4gBNUYAMhn7aNR0nVN52WnaDpOkAA)
```typescript
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer U) => any ? U : never
```
引数の型を`U`として、この型関数に`T`が一致するなら`U`が返る型を作りました


## Get Return Type
組み込みの型ユーティリティ`ReturnType<T>`を使用せず、`T`の戻り値の型を取得する型を実装します。
#### 例
```typescript
const fn = (v: boolean) => {
  if (v)
    return 1
  else
    return 2
}

type a = MyReturnType<typeof fn> // should be "1 | 2"
```

#### 実装
```typescript
type MyReturnType<T> = T extends (...arg: any) => infer U ? U : never
```
返り値の型を`U`とする型関数に、`T`が一致する場合は`U`を返す型を実装しました

## TupleToUnion
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCMAMEFoIBUCuAHANgUwgFwHsIBVAOwEsDTJEE76aAjATwgEFS8ALK1gMVQQAFAAEAhpwBmqAJQQAxIFo5QFi+C8qUnYATgrwYcC1BSpga88xEBXMYHlVU1ED9DIHWGQNcMgOwZAJAqBpBkCRDIDOGQNMMgFUMgM8MgNHqgEkMgPiugAhGgJoMgNEMAAZoWNjIBGSUpAA8yAB8ieGA+dqAoxGA6gyAfgyxgEAMdhCA0fKAEgyADgx1ie14AM40eMzouGxaOgC8EADaAOTQEwA0EBMATLPzAMwTALp1vf0o2J14EKMpOOmZVNmDWnkQwMAQ2AAe-QDGeNgAJvhEjLhTExAAH3mS0BqwmNHaiTq1wA4uQ8AAJVCMQDmDIAuj0AsVEJQBY-1w8Hh0J0AFy3LrPLgAOgAVp0KQQtABzYBwYBUsRgEDAUygCAAfX5AsFAoggGUGEWAawZAM0MgB+GQCTDOFABhRgFNFPlCtW8iCc0zbXDHNIZYw5fKHFD3B5vUjvTrsIZiZjZdSaHTEa4AfhIECJEFI2AAbtpuSBVerBRBAGMMgE6GQATDIBGhmlEeDIf5mq55AAtuh6QcdRAAN4QACiAEdUGJMHMC09sK8IABfCCSLQENPzEQ6hDkss4UgMvbAVB4ciYTrgsA555iTp7E1jGiVl54bLF0uYXL6fVnHJjaALFZzCYAFgArAA2ZZ4LSobDrPJzHcrUGH0--IEXq95W9zquvJclstr1JTkNbJt13G8713D8ZjATYwB5JNQ0AQmtXAjMNAGGGRxEyTFM4PAKBrkAY8jABVvcJAEdFQBIcxxPECWJUlOnJalaXpJkWQkToAHdtFZdl8IgYjwkAaMj4lxfFCRJYAyUpGk6UZZlYGAToCEwAcsm6XjAF0GVxADW5VxACaowAZDJEmjxMkxiZKZNkOS5IA)


## Omit
組み込みの型ユーティリティ`Omit<T, K>`を使用せず、`T`のプロパティから`K`を削除する型を実装します。

#### 例
```typescript
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```
#### 実装
[Playground](https://www.typescriptlang.org/play?ssl=32&ssc=2&pln=30&pc=1#code/PQKgUABBDMELQQPIFsCWAXS8491gRgJ4QCCAdugBYD2ZxAYgK4QAUAAgIYUBmjAlBADEgWjlAWL5DGZVLSH5GqADbo4qMmCyDNEQFcxgeVV1UQCK+gfwZAPfHHAdgyBo9UBnDIB+GQGMMgYoZAVwzOABigwAeACoAaCABpAD53QCSGQH95QApXQG0GQC0GQEAGd193C0B1hkBbhkBFhmdAaQZASIZ3IIjAKSVAEzTATQZAaIYrcMB87UBRiMB1BkA-BkrAIAYDCEBo+UAJBkAHBm73EfQAZyxVdABTACduDgBjaYhfagATaggAbywodAwFaYAuCDH0WdUAcz2IdemxxcuABwPaU-PLshuoKEXqZDPI4zdanfDUahHLhYAC+3XQhGeKzWmwACrNpgA3VDTADuEAAvBAALKELzoPwbaiBADk90eLzeZBpEAAPhAaQd0EcaSFuv8yOcIOgqacUdR0VicfiibtfhB-oDgdNQRAFgoxtN-LCsCN3N0QhAAOIYAASjHwgHMGQBdHoBYqJqgCx-yjodDPMbHYDAcaLSgAOgAVmNfdRZldgNBgP6OGAQMB1KAIAB9ZMp1MpiCAZQYM4BrBkAzQx2QCTDOFABhRgFNFJNpyuJiCxsAIpEksloCkBYIQaYADxmZHWYwgAGtpoRqNxVobZVgANoAVQgqggAFEO4sFIx7t5B8PR63QgBdMUz3dgOFgBNVysQByAToZABMMgEaGOxXivn9O11CAkPoYWIlbbRcAR0YDgFECJckUWL8YTVWYAQ5Nh62mOAfWAo5vgeYBGAODUaXUBCFQ4TU+yJScsDA6YIO8BdAOAyiO3AkEAEZAlJclKU2Wl6SeVBXmkZkQn47UoDIiiqKAhRaPolUACZmKbHxxQ4h4uJ42gWXZGlFSBaYQV5ASwCPU9gAgeCxjgTt6LM2YYNmOsf3bKyQ0JRtWIUjlOMZXi1I5VRMWA1B1l5dQpjmBZllWKkdiwLkjg+C5riwdzuKZWKvh+BUAS0kEwQhKE1BPYL5iWFZhMYyL9kOE4zji74sE05VVXBSFpmhfKKBCorFzo8iQSksrhQqlL4pPM8X3TQBCawsK8HEAYYZ0mfUaazjUAsENQBjyMAFW9wkAR0VAEhzR1nVdd1PW9P1A2DUNw2ALgxlxOZI2jKA1s2wBoyOqJ0XTdD0vUeU6gxDMMIzGSFMN4iZHogQBdBgsQA1uQsQAmqMAGQz3sOr6ToDP6LqjGM4yAA)
```typescript
type MyOmit<T, K extends keyof T> = {
  [U in Exclude<keyof T, K>]: T[U]
}
```
`Exclude<keyof T, K>`で`T`のプロパティから`K`を除いたユニオン型を作ります。それを`in`で`U`に展開して、`K`を除いた型を作りました


## Readonly 2
2つの型引数TとKを取る`MyReadonly2<T, K>`を実装します。

`K`が指定されている場合は、`T`の中の`K`のプロパティのみを読み取り専用にします。`K`が指定されていない場合は、通常の`Readonly<T>`と同様に、すべてのプロパティを読み取り専用にします。

#### 例
```typescript
interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: "Hey",
  description: "foobar",
  completed: false,
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
todo.completed = true // OK
```

#### 実装
```typescript
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [U in K]: T[U]
} & {
  [U in Exclude<keyof T, K>]: T[U]
}
```
`K`で渡されたプロパティを`readonly`にして、`T`のプロパティから`K`のプロパティを除いた型をそのまま追加するようにしました

デフォルト型引数初めて知りました

#### [デフォルト型引数](https://typescriptbook.jp/reference/generics/default-type-parameter)
型引数にデフォルトの型を指定することができる。型引数がなかったときはジェネリクス型`T`が`Error`になる

```typescript
type MyErrorEvent<T = Error> = {
  error: T;
  type: string;
};
```

型引数の制約と併用することもできる
```typescript
type MyErrorEvent<T extends Error = SyntaxError> = {
  error: T;
  type: string;
};
```
型を制約した場合は、デフォルトの型引数もその制約を満たす必要がある


## DeepReadonly
オブジェクトの全てのパラメータと、そのサブオブジェクトを再帰的に読み取り専用にする

#### 使い方例
```typescript
type X = {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

type Expected = {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

#### 実装
[Playground](https://www.typescriptlang.org/play?#code/PQKgUABBCcELQQCIFNkAcICVkEMAmA9gHYA2AnpPHNTZQEZkQCCRALgBbGMBiArhAAoAAjjYAzXgEoIAYkC0coCxfWQCdchUoxkE6AK2QBjVnADWyMgGdZeVGjCUZDiICuYwPKqdqICqGQGsMgDoZA5QyA9QyAEwyAdgyAmgyAngyAZgwhgIsMgJcMgIcMgD8MgP0MyYAQ-4BSDIARDIDODIC6DCGArQxe3v7BgEkMgLGKgAx6gCFugNYMgJD-lYC1UYD+DIBryoBRDIBAOoAUro1hgNEMAAYo6Nj4xOQAPAAqAHxjlYD52oCjEYDqDIB+DGGAQAzuEIDKDCGATVGAMhmA5gyA9gzlgaEdlYCORoDGDFGAIgwjgBYMgM8GgFnaWyigHkGQAGDIBVBg++0AsomAdCVAIAMgCLUwAOpvCAvFAJ0MgCsGQCWDDdAMABgDtDUaAUf1AIGRN0AQgw9HaAbQZAMkM+y2gGkGLbwwD3yoBfgKxgAU0nqADctAKAMWMAjQzJDGVQDVDIAFhmSo2O3yu8MAV4GAMCVlYBquMagERjQBkRvLvoAZBiugFkGPaHSiAaPlABIMgAcGI5jR2scyUVhkNDICAADQgAF4IABvShQAAeAC5A8GoBAcBGAIxRqB0CMAcnYAEsU1GAL5Rsip9hmLNQXOu92egCiIY9hmQeD9kejEFUMw0EHDjabzbUs0YsYgCa73db5AgyYgaczOajLfUo-zE8LZGLEFLUDdHogCwIhAbkzQ0znZDmXqWEGAwAg5k4vBI9bonvMOAAtp6cJYxlWa6w62NKI6-0oM8AHF01YAAJXg6CuQAuj0AWKjRkALH-2FYVg0HMMML2dfR2AAOh0cxcIIZQAHNgGgYAdBwMAQGAOxQAgAB9ZiWNYliTmORpAGaGZJAEmGSpAAwowBTRSYtixMYiBaLsDdPX3Q9e0WM9-SDKBZ17CAAG0AAUIHTIgIFMMgCDELcAF0IwWbTTIgZAQx-Ig8EsPgiEMdNiAgAB+LcrIgCM5J7DRFispYwFLBjxLEiBADGGDEgjFDFRIi9ipPTZ80GI1gIBkwMIArABHXgcBIAAaXLqwMTLswgMRlAIZ8JyEGS4BwoqSGQIgSOQcxgF4Vh0xIcwszAbL9HfLqGw0ygvwquZ8sKkg5n8kdjy9OMllK6bazwNb1qm8rDFmgqisWmx5MCr0ACZ1rK786yu3bTOk8tvTjBsVJjCMBGkX0zwui76AjcxWGUPSSMofQI3eqA8AjOgCAINrRCjZBIcTCASNRocoHYTGsagdMI2B3hkDRpsdFTIGQY6lch1zPHjALZASBIAgaejOmuxICNJrxycU2K0nOzx59ubTItHrx7MBaHCX2coXNS2yy63o+q9gdB1cIAAHxy8ciF4Z8H2UVcns3Taf22t7KDUtt+y+v1fv+1SAtHcdKdB62XcYCGheHI8IBhsd4cRogZy9mzcabG3Rwx32o-DnG467aPGAJrLlGJwXneWiByYnd3qcFjmhxTgzGeZ1m0eL6NS65v31J5rG+elrGoax0uRfrtsNLF5dZdplum37k2S1C03K32i2LpV0v+wLkjNZ1gMu9diN9cN5BjbCkBEqSiTAEJrEIMSiwBhhkAdYZd6SyS6NAICIEAY8jABVvSpAEdFQBIcyQlC0IwrDzBw-DCLETIhRUQ5gADum9KLUSgGeJ+lRADRkSMZCqF0KYWANhPCBEiKkXIsAcwCNepuSIC6GBEAiiADW5c4FxkHfzQRggB2CyJURonRIAA)
```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : DeepReadonly<T[P]>
}
```
以前作った、`Readonly`を拡張して、`T[P]`が関数の時はそのまま、違った場合は再帰的に`T[P]`を`DeepReadonly`します

`T`が`string`の時、`string`になるのなんで🤔
```typescript
type DeepReadonly<T extends object> = {
  readonly [P in keyof T]: T[P] extends Function ? T[P] : T[P] extends object ? DeepReadonly<T[P]> : T[P]
}
```
最初こうしてた
